{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#crewai-documentation","title":"crewAI Documentation","text":"<p>Cutting-edge framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks.</p> Getting Started <ul> <li>                     Installing CrewAI                  </li> <li>                     Start a New CrewAI Project: Template Method                  </li> <li>                      Create a New CrewAI Pipeline: Template Method                  </li> </ul> Core Concepts <ul> <li>                      Agents                  </li> <li>                      Tasks                  </li> <li>                      Tools                  </li> <li>                      Processes                  </li> <li>                      Crews                  </li> <li>                      LLMs                  </li> <li>                      Pipeline                  </li> <li>                      Training                  </li> <li>                      Memory                  </li> <li>                      Planning                  </li> <li>                      Testing                  </li> </ul> How-To Guides <ul> <li>                      Create Custom Tools                  </li> <li>                      Using Sequential Process                  </li> <li>                      Using Hierarchical Process                  </li> <li>                      Connecting to LLMs                  </li> <li>                      Customizing Agents                  </li> <li>                      Coding Agents                  </li> <li>                      Forcing Tool Output as Result                  </li> <li>                      Human Input on Execution                  </li> <li>                      Kickoff a Crew Asynchronously                  </li> <li>                      Kickoff a Crew for a List                  </li> <li>                      Replay from a Task                  </li> <li>                      Conditional Tasks                  </li> <li>                      Agent Monitoring with AgentOps                  </li> <li>                      Agent Monitoring with LangTrace                  </li> </ul>"},{"location":"core-concepts/Agents/","title":"crewAI Agents","text":""},{"location":"core-concepts/Agents/#what-is-an-agent","title":"What is an Agent?","text":"<p>What is an Agent?</p> <p>An agent is an autonomous unit programmed to: <ul> <li>Perform tasks</li> <li>Make decisions</li> <li>Communicate with other agents</li> </ul>  Think of an agent as a member of a team, with specific skills and a particular job to do. Agents can have different roles like 'Researcher', 'Writer', or 'Customer Support', each contributing to the overall goal of the crew.</p>"},{"location":"core-concepts/Agents/#agent-attributes","title":"Agent Attributes","text":"Attribute Parameter Description Role <code>role</code> Defines the agent's function within the crew. It determines the kind of tasks the agent is best suited for. Goal <code>goal</code> The individual objective that the agent aims to achieve. It guides the agent's decision-making process. Backstory <code>backstory</code> Provides context to the agent's role and goal, enriching the interaction and collaboration dynamics. LLM (optional) <code>llm</code> Represents the language model that will run the agent. It dynamically fetches the model name from the <code>OPENAI_MODEL_NAME</code> environment variable, defaulting to \"gpt-4\" if not specified. Tools (optional) <code>tools</code> Set of capabilities or functions that the agent can use to perform tasks. Expected to be instances of custom classes compatible with the agent's execution environment. Tools are initialized with a default value of an empty list. Function Calling LLM (optional) <code>function_calling_llm</code> Specifies the language model that will handle the tool calling for this agent, overriding the crew function calling LLM if passed. Default is <code>None</code>. Max Iter (optional) <code>max_iter</code> Max Iter is the maximum number of iterations the agent can perform before being forced to give its best answer. Default is <code>25</code>. Max RPM (optional) <code>max_rpm</code> Max RPM is the maximum number of requests per minute the agent can perform to avoid rate limits. It's optional and can be left unspecified, with a default value of <code>None</code>. Max Execution Time (optional) <code>max_execution_time</code> Max Execution Time is the maximum execution time for an agent to execute a task. It's optional and can be left unspecified, with a default value of <code>None</code>, meaning no max execution time. Verbose (optional) <code>verbose</code> Setting this to <code>True</code> configures the internal logger to provide detailed execution logs, aiding in debugging and monitoring. Default is <code>False</code>. Allow Delegation (optional) <code>allow_delegation</code> Agents can delegate tasks or questions to one another, ensuring that each task is handled by the most suitable agent. Default is <code>False</code>. Step Callback (optional) <code>step_callback</code> A function that is called after each step of the agent. This can be used to log the agent's actions or to perform other operations. It will overwrite the crew <code>step_callback</code>. Cache (optional) <code>cache</code> Indicates if the agent should use a cache for tool usage. Default is <code>True</code>. System Template (optional) <code>system_template</code> Specifies the system format for the agent. Default is <code>None</code>. Prompt Template (optional) <code>prompt_template</code> Specifies the prompt format for the agent. Default is <code>None</code>. Response Template (optional) <code>response_template</code> Specifies the response format for the agent. Default is <code>None</code>. Allow Code Execution (optional) <code>allow_code_execution</code> Enable code execution for the agent. Default is <code>False</code>. Max Retry Limit (optional) <code>max_retry_limit</code> Maximum number of retries for an agent to execute a task when an error occurs. Default is <code>2</code>. Use System Prompt (optional) <code>use_system_prompt</code> Adds the ability to not use system prompt (to support o1 models). Default is <code>True</code>. Respect Context Window (optional) <code>respect_context_window</code> Summary strategy to avoid overflowing the context window. Default is <code>True</code>."},{"location":"core-concepts/Agents/#creating-an-agent","title":"Creating an Agent","text":"<p>Agent Interaction</p> <p>Agents can interact with each other using crewAI's built-in delegation and communication mechanisms. This allows for dynamic task management and problem-solving within the crew.</p> <p>To create an agent, you would typically initialize an instance of the <code>Agent</code> class with the desired properties. Here's a conceptual example including all attributes:</p> <pre><code># Example: Creating an agent with all attributes\nfrom crewai import Agent\n\nagent = Agent(\n  role='Data Analyst',\n  goal='Extract actionable insights',\n  backstory=\"\"\"You're a data analyst at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\n  You're currently working on a project to analyze the\n  performance of our marketing campaigns.\"\"\",\n  tools=[my_tool1, my_tool2],  # Optional, defaults to an empty list\n  llm=my_llm,  # Optional\n  function_calling_llm=my_llm,  # Optional\n  max_iter=15,  # Optional\n  max_rpm=None, # Optional\n  max_execution_time=None, # Optional\n  verbose=True,  # Optional\n  allow_delegation=False,  # Optional\n  step_callback=my_intermediate_step_callback,  # Optional\n  cache=True,  # Optional\n  system_template=my_system_template,  # Optional\n  prompt_template=my_prompt_template,  # Optional\n  response_template=my_response_template,  # Optional\n  config=my_config,  # Optional\n  crew=my_crew,  # Optional\n  tools_handler=my_tools_handler,  # Optional\n  cache_handler=my_cache_handler,  # Optional\n  callbacks=[callback1, callback2],  # Optional\n  allow_code_execution=True,  # Optional\n  max_retry_limit=2,  # Optional\n  use_system_prompt=True,  # Optional\n  respect_context_window=True,  # Optional\n)\n</code></pre>"},{"location":"core-concepts/Agents/#setting-prompt-templates","title":"Setting prompt templates","text":"<p>Prompt templates are used to format the prompt for the agent. You can use to update the system, regular and response templates for the agent. Here's an example of how to set prompt templates:</p> <pre><code>agent = Agent(\n        role=\"{topic} specialist\",\n        goal=\"Figure {goal} out\",\n        backstory=\"I am the master of {role}\",\n        system_template=\"\"\"&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;\n\n{{ .System }}&lt;|eot_id|&gt;\"\"\",\n        prompt_template=\"\"\"&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;\n\n{{ .Prompt }}&lt;|eot_id|&gt;\"\"\",\n        response_template=\"\"\"&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;\n\n{{ .Response }}&lt;|eot_id|&gt;\"\"\",\n    )\n</code></pre>"},{"location":"core-concepts/Agents/#bring-your-third-party-agents","title":"Bring your Third Party Agents","text":"<p>Extend your Third Party Agents like LlamaIndex, Langchain, Autogen or fully custom agents using the the crewai's BaseAgent class.</p> <p>BaseAgent includes attributes and methods required to integrate with your crews to run and delegate tasks to other agents within your own crew.</p> <p>CrewAI is a universal multi-agent framework that allows for all agents to work together to automate tasks and solve problems.</p> <pre><code>from crewai import Agent, Task, Crew\nfrom custom_agent import CustomAgent # You need to build and extend your own agent logic with the CrewAI BaseAgent class then import it here.\n\nfrom langchain.agents import load_tools\n\nlangchain_tools = load_tools([\"google-serper\"], llm=llm)\n\nagent1 = CustomAgent(\n    role=\"agent role\",\n    goal=\"who is {input}?\",\n    backstory=\"agent backstory\",\n    verbose=True,\n)\n\ntask1 = Task(\n    expected_output=\"a short biography of {input}\",\n    description=\"a short biography of {input}\",\n    agent=agent1,\n)\n\nagent2 = Agent(\n    role=\"agent role\",\n    goal=\"summarize the short bio for {input} and if needed do more research\",\n    backstory=\"agent backstory\",\n    verbose=True,\n)\n\ntask2 = Task(\n    description=\"a tldr summary of the short biography\",\n    expected_output=\"5 bullet point summary of the biography\",\n    agent=agent2,\n    context=[task1],\n)\n\nmy_crew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew = my_crew.kickoff(inputs={\"input\": \"Mark Twain\"})\n</code></pre>"},{"location":"core-concepts/Agents/#conclusion","title":"Conclusion","text":"<p>Agents are the building blocks of the CrewAI framework. By understanding how to define and interact with agents, you can create sophisticated AI systems that leverage the power of collaborative intelligence.</p>"},{"location":"core-concepts/Cli/","title":"CrewAI CLI Documentation","text":"<p>The CrewAI CLI provides a set of commands to interact with CrewAI, allowing you to create, train, run, and manage crews and pipelines.</p>"},{"location":"core-concepts/Cli/#installation","title":"Installation","text":"<p>To use the CrewAI CLI, make sure you have CrewAI &amp; Poetry installed:</p> <pre><code>pip install crewai poetry\n</code></pre>"},{"location":"core-concepts/Cli/#basic-usage","title":"Basic Usage","text":"<p>The basic structure of a CrewAI CLI command is:</p> <pre><code>crewai [COMMAND] [OPTIONS] [ARGUMENTS]\n</code></pre>"},{"location":"core-concepts/Cli/#available-commands","title":"Available Commands","text":""},{"location":"core-concepts/Cli/#1-create","title":"1. create","text":"<p>Create a new crew or pipeline.</p> <pre><code>crewai create [OPTIONS] TYPE NAME\n</code></pre> <ul> <li><code>TYPE</code>: Choose between \"crew\" or \"pipeline\"</li> <li><code>NAME</code>: Name of the crew or pipeline</li> <li><code>--router</code>: (Optional) Create a pipeline with router functionality</li> </ul> <p>Example: <pre><code>crewai create crew my_new_crew\ncrewai create pipeline my_new_pipeline --router\n</code></pre></p>"},{"location":"core-concepts/Cli/#2-version","title":"2. version","text":"<p>Show the installed version of CrewAI.</p> <pre><code>crewai version [OPTIONS]\n</code></pre> <ul> <li><code>--tools</code>: (Optional) Show the installed version of CrewAI tools</li> </ul> <p>Example: <pre><code>crewai version\ncrewai version --tools\n</code></pre></p>"},{"location":"core-concepts/Cli/#3-train","title":"3. train","text":"<p>Train the crew for a specified number of iterations.</p> <pre><code>crewai train [OPTIONS]\n</code></pre> <ul> <li><code>-n, --n_iterations INTEGER</code>: Number of iterations to train the crew (default: 5)</li> <li><code>-f, --filename TEXT</code>: Path to a custom file for training (default: \"trained_agents_data.pkl\")</li> </ul> <p>Example: <pre><code>crewai train -n 10 -f my_training_data.pkl\n</code></pre></p>"},{"location":"core-concepts/Cli/#4-replay","title":"4. replay","text":"<p>Replay the crew execution from a specific task.</p> <pre><code>crewai replay [OPTIONS]\n</code></pre> <ul> <li><code>-t, --task_id TEXT</code>: Replay the crew from this task ID, including all subsequent tasks</li> </ul> <p>Example: <pre><code>crewai replay -t task_123456\n</code></pre></p>"},{"location":"core-concepts/Cli/#5-log_tasks_outputs","title":"5. log_tasks_outputs","text":"<p>Retrieve your latest crew.kickoff() task outputs.</p> <pre><code>crewai log_tasks_outputs\n</code></pre>"},{"location":"core-concepts/Cli/#6-reset_memories","title":"6. reset_memories","text":"<p>Reset the crew memories (long, short, entity, latest_crew_kickoff_outputs).</p> <pre><code>crewai reset_memories [OPTIONS]\n</code></pre> <ul> <li><code>-l, --long</code>: Reset LONG TERM memory</li> <li><code>-s, --short</code>: Reset SHORT TERM memory</li> <li><code>-e, --entities</code>: Reset ENTITIES memory</li> <li><code>-k, --kickoff-outputs</code>: Reset LATEST KICKOFF TASK OUTPUTS</li> <li><code>-a, --all</code>: Reset ALL memories</li> </ul> <p>Example: <pre><code>crewai reset_memories --long --short\ncrewai reset_memories --all\n</code></pre></p>"},{"location":"core-concepts/Cli/#7-test","title":"7. test","text":"<p>Test the crew and evaluate the results.</p> <pre><code>crewai test [OPTIONS]\n</code></pre> <ul> <li><code>-n, --n_iterations INTEGER</code>: Number of iterations to test the crew (default: 3)</li> <li><code>-m, --model TEXT</code>: LLM Model to run the tests on the Crew (default: \"gpt-4o-mini\")</li> </ul> <p>Example: <pre><code>crewai test -n 5 -m gpt-3.5-turbo\n</code></pre></p>"},{"location":"core-concepts/Cli/#8-run","title":"8. run","text":"<p>Run the crew.</p> <pre><code>crewai run\n</code></pre>"},{"location":"core-concepts/Cli/#note","title":"Note","text":"<p>Make sure to run these commands from the directory where your CrewAI project is set up. Some commands may require additional configuration or setup within your project structure.</p>"},{"location":"core-concepts/Collaboration/","title":"How Agents Collaborate in CrewAI","text":""},{"location":"core-concepts/Collaboration/#collaboration-fundamentals","title":"Collaboration Fundamentals","text":"<p>Core of Agent Interaction</p> <p>Collaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem.</p> <ul> <li>Information Sharing: Ensures all agents are well-informed and can contribute effectively by sharing data and findings.</li> <li>Task Assistance: Allows agents to seek help from peers with the required expertise for specific tasks.</li> <li>Resource Allocation: Optimizes task execution through the efficient distribution and sharing of resources among agents.</li> </ul>"},{"location":"core-concepts/Collaboration/#enhanced-attributes-for-improved-collaboration","title":"Enhanced Attributes for Improved Collaboration","text":"<p>The <code>Crew</code> class has been enriched with several attributes to support advanced functionalities:</p> <ul> <li>Language Model Management (<code>manager_llm</code>, <code>function_calling_llm</code>): Manages language models for executing tasks and tools, facilitating sophisticated agent-tool interactions. Note that while <code>manager_llm</code> is mandatory for hierarchical processes to ensure proper execution flow, <code>function_calling_llm</code> is optional, with a default value provided for streamlined tool interaction.</li> <li>Custom Manager Agent (<code>manager_agent</code>): Allows specifying a custom agent as the manager instead of using the default manager provided by CrewAI.</li> <li>Process Flow (<code>process</code>): Defines the execution logic (e.g., sequential, hierarchical) to streamline task distribution and execution.</li> <li>Verbose Logging (<code>verbose</code>): Offers detailed logging capabilities for monitoring and debugging purposes. It supports both integer and boolean types to indicate the verbosity level. For example, setting <code>verbose</code> to 1 might enable basic logging, whereas setting it to True enables more detailed logs.</li> <li>Rate Limiting (<code>max_rpm</code>): Ensures efficient utilization of resources by limiting requests per minute. Guidelines for setting <code>max_rpm</code> should consider the complexity of tasks and the expected load on resources.</li> <li>Internationalization / Customization Support (<code>language</code>, <code>prompt_file</code>): Facilitates full customization of the inner prompts, enhancing global usability. Supported languages and the process for utilizing the <code>prompt_file</code> attribute for customization should be clearly documented. Example of file</li> <li>Execution and Output Handling (<code>full_output</code>): Distinguishes between full and final outputs for nuanced control over task results. Examples showcasing the difference in outputs can aid in understanding the practical implications of this attribute.</li> <li>Callback and Telemetry (<code>step_callback</code>, <code>task_callback</code>): Integrates callbacks for step-wise and task-level execution monitoring, alongside telemetry for performance analytics. The purpose and usage of <code>task_callback</code> alongside <code>step_callback</code> for granular monitoring should be clearly explained.</li> <li>Crew Sharing (<code>share_crew</code>): Enables sharing of crew information with CrewAI for continuous improvement and training models. The privacy implications and benefits of this feature, including how it contributes to model improvement, should be outlined.</li> <li>Usage Metrics (<code>usage_metrics</code>): Stores all metrics for the language model (LLM) usage during all tasks' execution, providing insights into operational efficiency and areas for improvement. Detailed information on accessing and interpreting these metrics for performance analysis should be provided.</li> <li>Memory Usage (<code>memory</code>): Indicates whether the crew should use memory to store memories of its execution, enhancing task execution and agent learning.</li> <li>Embedder Configuration (<code>embedder</code>): Specifies the configuration for the embedder to be used by the crew for understanding and generating language. This attribute supports customization of the language model provider.</li> <li>Cache Management (<code>cache</code>): Determines whether the crew should use a cache to store the results of tool executions, optimizing performance.</li> <li>Output Logging (<code>output_log_file</code>): Specifies the file path for logging the output of the crew's execution.</li> <li>Planning Mode (<code>planning</code>): Allows crews to plan their actions before executing tasks by setting <code>planning=True</code> when creating the <code>Crew</code> instance. This feature enhances coordination and efficiency.</li> <li>Replay Feature: Introduces a new CLI for listing tasks from the last run and replaying from a specific task, enhancing task management and troubleshooting.</li> </ul>"},{"location":"core-concepts/Collaboration/#delegation-dividing-to-conquer","title":"Delegation: Dividing to Conquer","text":"<p>Delegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability.</p>"},{"location":"core-concepts/Collaboration/#implementing-collaboration-and-delegation","title":"Implementing Collaboration and Delegation","text":"<p>Setting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.</p>"},{"location":"core-concepts/Collaboration/#example-scenario","title":"Example Scenario","text":"<p>Consider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.</p>"},{"location":"core-concepts/Collaboration/#conclusion","title":"Conclusion","text":"<p>The integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.</p>"},{"location":"core-concepts/Crews/","title":"crewAI Crews","text":""},{"location":"core-concepts/Crews/#what-is-a-crew","title":"What is a Crew?","text":"<p>A crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow.</p>"},{"location":"core-concepts/Crews/#crew-attributes","title":"Crew Attributes","text":"Attribute Parameters Description Tasks <code>tasks</code> A list of tasks assigned to the crew. Agents <code>agents</code> A list of agents that are part of the crew. Process (optional) <code>process</code> The process flow (e.g., sequential, hierarchical) the crew follows. Default is <code>sequential</code>. Verbose (optional) <code>verbose</code> The verbosity level for logging during execution. Defaults to <code>False</code>. Manager LLM (optional) <code>manager_llm</code> The language model used by the manager agent in a hierarchical process. Required when using a hierarchical process. Function Calling LLM (optional) <code>function_calling_llm</code> If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling. Config (optional) <code>config</code> Optional configuration settings for the crew, in <code>Json</code> or <code>Dict[str, Any]</code> format. Max RPM (optional) <code>max_rpm</code> Maximum requests per minute the crew adheres to during execution. Defaults to <code>None</code>. Language (optional) <code>language</code> Language used for the crew, defaults to English. Language File (optional) <code>language_file</code> Path to the language file to be used for the crew. Memory (optional) <code>memory</code> Utilized for storing execution memories (short-term, long-term, entity memory). Defaults to <code>False</code>. Cache (optional) <code>cache</code> Specifies whether to use a cache for storing the results of tools' execution. Defaults to <code>True</code>. Embedder (optional) <code>embedder</code> Configuration for the embedder to be used by the crew. Mostly used by memory for now. Default is <code>{\"provider\": \"openai\"}</code>. Full Output (optional) <code>full_output</code> Whether the crew should return the full output with all tasks outputs or just the final output. Defaults to <code>False</code>. Step Callback (optional) <code>step_callback</code> A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific <code>step_callback</code>. Task Callback (optional) <code>task_callback</code> A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution. Share Crew (optional) <code>share_crew</code> Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models. Output Log File (optional) <code>output_log_file</code> Whether you want to have a file with the complete crew output and execution. You can set it using True and it will default to the folder you are currently in and it will be called logs.txt or passing a string with the full path and name of the file. Manager Agent (optional) <code>manager_agent</code> <code>manager</code> sets a custom agent that will be used as a manager. Manager Callbacks (optional) <code>manager_callbacks</code> <code>manager_callbacks</code> takes a list of callback handlers to be executed by the manager agent when a hierarchical process is used. Prompt File (optional) <code>prompt_file</code> Path to the prompt JSON file to be used for the crew. Planning (optional) <code>planning</code> Adds planning ability to the Crew. When activated before each Crew iteration, all Crew data is sent to an AgentPlanner that will plan the tasks and this plan will be added to each task description. Planning LLM (optional) <code>planning_llm</code> The language model used by the AgentPlanner in a planning process. <p>Crew Max RPM</p> <p>The <code>max_rpm</code> attribute sets the maximum number of requests per minute the crew can perform to avoid rate limits and will override individual agents' <code>max_rpm</code> settings if you set it.</p>"},{"location":"core-concepts/Crews/#crew-output","title":"Crew Output","text":"<p>Understanding Crew Outputs</p> <p>The output of a crew in the crewAI framework is encapsulated within the <code>CrewOutput</code> class. This class provides a structured way to access results of the crew's execution, including various formats such as raw strings, JSON, and Pydantic models. The <code>CrewOutput</code> includes the results from the final task output, token usage, and individual task outputs.</p>"},{"location":"core-concepts/Crews/#crew-output-attributes","title":"Crew Output Attributes","text":"Attribute Parameters Type Description Raw <code>raw</code> <code>str</code> The raw output of the crew. This is the default format for the output. Pydantic <code>pydantic</code> <code>Optional[BaseModel]</code> A Pydantic model object representing the structured output of the crew. JSON Dict <code>json_dict</code> <code>Optional[Dict[str, Any]]</code> A dictionary representing the JSON output of the crew. Tasks Output <code>tasks_output</code> <code>List[TaskOutput]</code> A list of <code>TaskOutput</code> objects, each representing the output of a task in the crew. Token Usage <code>token_usage</code> <code>Dict[str, Any]</code> A summary of token usage, providing insights into the language model's performance during execution."},{"location":"core-concepts/Crews/#crew-output-methods-and-properties","title":"Crew Output Methods and Properties","text":"Method/Property Description json Returns the JSON string representation of the crew output if the output format is JSON. to_dict Converts the JSON and Pydantic outputs to a dictionary. **str** Returns the string representation of the crew output, prioritizing Pydantic, then JSON, then raw."},{"location":"core-concepts/Crews/#accessing-crew-outputs","title":"Accessing Crew Outputs","text":"<p>Once a crew has been executed, its output can be accessed through the <code>output</code> attribute of the <code>Crew</code> object. The <code>CrewOutput</code> class provides various ways to interact with and present this output.</p>"},{"location":"core-concepts/Crews/#example","title":"Example","text":"<pre><code># Example crew execution\ncrew = Crew(\n    agents=[research_agent, writer_agent],\n    tasks=[research_task, write_article_task],\n    verbose=True\n)\n\ncrew_output = crew.kickoff()\n\n# Accessing the crew output\nprint(f\"Raw Output: {crew_output.raw}\")\nif crew_output.json_dict:\n    print(f\"JSON Output: {json.dumps(crew_output.json_dict, indent=2)}\")\nif crew_output.pydantic:\n    print(f\"Pydantic Output: {crew_output.pydantic}\")\nprint(f\"Tasks Output: {crew_output.tasks_output}\")\nprint(f\"Token Usage: {crew_output.token_usage}\")\n</code></pre>"},{"location":"core-concepts/Crews/#memory-utilization","title":"Memory Utilization","text":"<p>Crews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.</p>"},{"location":"core-concepts/Crews/#cache-utilization","title":"Cache Utilization","text":"<p>Caches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks.</p>"},{"location":"core-concepts/Crews/#crew-usage-metrics","title":"Crew Usage Metrics","text":"<p>After the crew execution, you can access the <code>usage_metrics</code> attribute to view the language model (LLM) usage metrics for all tasks executed by the crew. This provides insights into operational efficiency and areas for improvement.</p> <pre><code># Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)\n</code></pre>"},{"location":"core-concepts/Crews/#crew-execution-process","title":"Crew Execution Process","text":"<ul> <li>Sequential Process: Tasks are executed one after another, allowing for a linear flow of work.</li> <li>Hierarchical Process: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. Note: A <code>manager_llm</code> or <code>manager_agent</code> is required for this process and it's essential for validating the process flow.</li> </ul>"},{"location":"core-concepts/Crews/#kicking-off-a-crew","title":"Kicking Off a Crew","text":"<p>Once your crew is assembled, initiate the workflow with the <code>kickoff()</code> method. This starts the execution process according to the defined process flow.</p> <pre><code># Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n</code></pre>"},{"location":"core-concepts/Crews/#different-ways-to-kick-off-a-crew","title":"Different Ways to Kick Off a Crew","text":"<p>Once your crew is assembled, initiate the workflow with the appropriate kickoff method. CrewAI provides several methods for better control over the kickoff process: <code>kickoff()</code>, <code>kickoff_for_each()</code>, <code>kickoff_async()</code>, and <code>kickoff_for_each_async()</code>.</p> <ul> <li><code>kickoff()</code>: Starts the execution process according to the defined process flow.</li> <li><code>kickoff_for_each()</code>: Executes tasks for each agent individually.</li> <li><code>kickoff_async()</code>: Initiates the workflow asynchronously.</li> <li><code>kickoff_for_each_async()</code>: Executes tasks for each agent individually in an asynchronous manner.</li> </ul> <pre><code># Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n\n# Example of using kickoff_for_each\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nresults = my_crew.kickoff_for_each(inputs=inputs_array)\nfor result in results:\n    print(result)\n\n# Example of using kickoff_async\ninputs = {'topic': 'AI in healthcare'}\nasync_result = my_crew.kickoff_async(inputs=inputs)\nprint(async_result)\n\n# Example of using kickoff_for_each_async\ninputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]\nasync_results = my_crew.kickoff_for_each_async(inputs=inputs_array)\nfor async_result in async_results:\n    print(async_result)\n</code></pre> <p>These methods provide flexibility in how you manage and execute tasks within your crew, allowing for both synchronous and asynchronous workflows tailored to your needs.</p>"},{"location":"core-concepts/Crews/#replaying-from-a-specific-task","title":"Replaying from a Specific Task","text":"<p>You can now replay from a specific task using our CLI command <code>replay</code>.</p> <p>The replay feature in CrewAI allows you to replay from a specific task using the command-line interface (CLI). By running the command <code>crewai replay -t &lt;task_id&gt;</code>, you can specify the <code>task_id</code> for the replay process.</p> <p>Kickoffs will now save the latest kickoffs returned task outputs locally for you to be able to replay from.</p>"},{"location":"core-concepts/Crews/#replaying-from-a-specific-task-using-the-cli","title":"Replaying from a Specific Task Using the CLI","text":"<p>To use the replay feature, follow these steps:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Navigate to the directory where your CrewAI project is located.</li> <li>Run the following command:</li> </ol> <p>To view the latest kickoff task IDs, use:</p> <pre><code>crewai log-tasks-outputs\n</code></pre> <p>Then, to replay from a specific task, use:</p> <pre><code>crewai replay -t &lt;task_id&gt;\n</code></pre> <p>These commands let you replay from your latest kickoff tasks, still retaining context from previously executed tasks.</p>"},{"location":"core-concepts/Flows/","title":"CrewAI Flows","text":""},{"location":"core-concepts/Flows/#introduction","title":"Introduction","text":"<p>CrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations.</p> <p>Flows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI's capabilities.</p> <ol> <li> <p>Simplified Workflow Creation: Easily chain together multiple Crews and tasks to create complex AI workflows.</p> </li> <li> <p>State Management: Flows make it super easy to manage and share state between different tasks in your workflow.</p> </li> <li> <p>Event-Driven Architecture: Built on an event-driven model, allowing for dynamic and responsive workflows.</p> </li> <li> <p>Flexible Control Flow: Implement conditional logic, loops, and branching within your workflows.</p> </li> </ol>"},{"location":"core-concepts/Flows/#getting-started","title":"Getting Started","text":"<p>Let's create a simple Flow where you will use OpenAI to generate a random city in one task and then use that city to generate a fun fact in another task.</p> <pre><code>import asyncio\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        return fun_fact\n\n\nasync def main():\n    flow = ExampleFlow()\n    result = await flow.kickoff()\n\n    print(f\"Generated fun fact: {result}\")\n\nasyncio.run(main())\n</code></pre> <p>In the above example, we have created a simple Flow that generates a random city using OpenAI and then generates a fun fact about that city. The Flow consists of two tasks: <code>generate_city</code> and <code>generate_fun_fact</code>. The <code>generate_city</code> task is the starting point of the Flow, and the <code>generate_fun_fact</code> task listens for the output of the <code>generate_city</code> task.</p> <p>When you run the Flow, it will generate a random city and then generate a fun fact about that city. The output will be printed to the console.</p>"},{"location":"core-concepts/Flows/#start","title":"@start()","text":"<p>The <code>@start()</code> decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with <code>@start()</code> are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.</p>"},{"location":"core-concepts/Flows/#listen","title":"@listen()","text":"<p>The <code>@listen()</code> decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with <code>@listen()</code> will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument.</p>"},{"location":"core-concepts/Flows/#usage","title":"Usage","text":"<p>The <code>@listen()</code> decorator can be used in several ways:</p> <ol> <li>Listening to a Method by Name: You can pass the name of the method you want to listen to as a string. When that method completes, the listener method will be triggered.</li> </ol> <pre><code>@listen(\"generate_city\")\ndef generate_fun_fact(self, random_city):\n    # Implementation\n</code></pre> <ol> <li>Listening to a Method Directly: You can pass the method itself. When that method completes, the listener method will be triggered.    <pre><code>@listen(generate_city)\ndef generate_fun_fact(self, random_city):\n    # Implementation\n</code></pre></li> </ol>"},{"location":"core-concepts/Flows/#flow-output","title":"Flow Output","text":"<p>Accessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.</p>"},{"location":"core-concepts/Flows/#retrieving-the-final-output","title":"Retrieving the Final Output","text":"<p>When you run a Flow, the final output is determined by the last method that completes. The <code>kickoff()</code> method returns the output of this final method.</p> <p>Here's how you can access the final output:</p> <pre><code>import asyncio\nfrom crewai.flow.flow import Flow, listen, start\n\nclass OutputExampleFlow(Flow):\n    @start()\n    def first_method(self):\n        return \"Output from first_method\"\n\n    @listen(first_method)\n    def second_method(self, first_output):\n        return f\"Second method received: {first_output}\"\n\nasync def main():\n    flow = OutputExampleFlow()\n    final_output = await flow.kickoff()\n    print(\"---- Final Output ----\")\n    print(final_output)\n\nasyncio.run(main())\n</code></pre> <p>In this example, the <code>second_method</code> is the last method to complete, so its output will be the final output of the Flow. The <code>kickoff()</code> method will return this final output, which is then printed to the console.</p> <p>The output of the Flow will be:</p> <pre><code>---- Final Output ----\nSecond method received: Output from first_method\n</code></pre>"},{"location":"core-concepts/Flows/#accessing-and-updating-state","title":"Accessing and Updating State","text":"<p>In addition to retrieving the final output, you can also access and update the state within your Flow. The state can be used to store and share data between different methods in the Flow. After the Flow has run, you can access the state to retrieve any information that was added or updated during the execution.</p> <p>Here's an example of how to update and access the state:</p> <pre><code>import asyncio\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\nclass ExampleState(BaseModel):\n    counter: int = 0\n    message: str = \"\"\n\nclass StateExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        self.state.message = \"Hello from first_method\"\n        self.state.counter += 1\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.message += \" - updated by second_method\"\n        self.state.counter += 1\n        return self.state.message\n\nasync def main():\n    flow = StateExampleFlow()\n    final_output = await flow.kickoff()\n    print(f\"Final Output: {final_output}\")\n    print(\"Final State:\")\n    print(flow.state)\n\nasyncio.run(main())\n</code></pre> <p>In this example, the state is updated by both <code>first_method</code> and <code>second_method</code>. After the Flow has run, you can access the final state to see the updates made by these methods.</p> <p>The output of the Flow will be:</p> <pre><code>Final Output: Hello from first_method - updated by second_method\nFinal State:\ncounter=2 message='Hello from first_method - updated by second_method'\n</code></pre> <p>By ensuring that the final method's output is returned and providing access to the state, CrewAI Flows make it easy to integrate the results of your AI workflows into larger applications or systems, while also maintaining and accessing the state throughout the Flow's execution.</p>"},{"location":"core-concepts/Flows/#flow-state-management","title":"Flow State Management","text":"<p>Managing state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management, allowing developers to choose the approach that best fits their application's needs.</p>"},{"location":"core-concepts/Flows/#unstructured-state-management","title":"Unstructured State Management","text":"<p>In unstructured state management, all state is stored in the <code>state</code> attribute of the <code>Flow</code> class. This approach offers flexibility, enabling developers to add or modify state attributes on the fly without defining a strict schema.</p> <pre><code>import asyncio\n\nfrom crewai.flow.flow import Flow, listen, start\n\nclass UntructuredExampleFlow(Flow):\n\n    @start()\n    def first_method(self):\n        self.state.message = \"Hello from structured flow\"\n        self.state.counter = 0\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nasync def main():\n    flow = UntructuredExampleFlow()\n    await flow.kickoff()\n\n\nasyncio.run(main())\n</code></pre> <p>Key Points:</p> <ul> <li>Flexibility: You can dynamically add attributes to <code>self.state</code> without predefined constraints.</li> <li>Simplicity: Ideal for straightforward workflows where state structure is minimal or varies significantly.</li> </ul>"},{"location":"core-concepts/Flows/#structured-state-management","title":"Structured State Management","text":"<p>Structured state management leverages predefined schemas to ensure consistency and type safety across the workflow. By using models like Pydantic's <code>BaseModel</code>, developers can define the exact shape of the state, enabling better validation and auto-completion in development environments.</p> <pre><code>import asyncio\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\n\nclass ExampleState(BaseModel):\n    counter: int = 0\n    message: str = \"\"\n\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n\n    @start()\n    def first_method(self):\n        self.state.message = \"Hello from structured flow\"\n\n    @listen(first_method)\n    def second_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated\"\n\n    @listen(second_method)\n    def third_method(self):\n        self.state.counter += 1\n        self.state.message += \" - updated again\"\n\n        print(f\"State after third_method: {self.state}\")\n\n\nasync def main():\n    flow = StructuredExampleFlow()\n    await flow.kickoff()\n\n\nasyncio.run(main())\n</code></pre> <p>Key Points:</p> <ul> <li>Defined Schema: <code>ExampleState</code> clearly outlines the state structure, enhancing code readability and maintainability.</li> <li>Type Safety: Leveraging Pydantic ensures that state attributes adhere to the specified types, reducing runtime errors.</li> <li>Auto-Completion: IDEs can provide better auto-completion and error checking based on the defined state model.</li> </ul>"},{"location":"core-concepts/Flows/#choosing-between-unstructured-and-structured-state-management","title":"Choosing Between Unstructured and Structured State Management","text":"<ul> <li> <p>Use Unstructured State Management when:</p> </li> <li> <p>The workflow's state is simple or highly dynamic.</p> </li> <li>Flexibility is prioritized over strict state definitions.</li> <li> <p>Rapid prototyping is required without the overhead of defining schemas.</p> </li> <li> <p>Use Structured State Management when:</p> </li> <li>The workflow requires a well-defined and consistent state structure.</li> <li>Type safety and validation are important for your application's reliability.</li> <li>You want to leverage IDE features like auto-completion and type checking for better developer experience.</li> </ul> <p>By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.</p>"},{"location":"core-concepts/Flows/#flow-control","title":"Flow Control","text":""},{"location":"core-concepts/Flows/#conditional-logic","title":"Conditional Logic","text":""},{"location":"core-concepts/Flows/#or","title":"or","text":"<p>The <code>or_</code> function in Flows allows you to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.</p> <pre><code>import asyncio\nfrom crewai.flow.flow import Flow, listen, or_, start\n\nclass OrExampleFlow(Flow):\n\n    @start()\n    def start_method(self):\n        return \"Hello from the start method\"\n\n    @listen(start_method)\n    def second_method(self):\n        return \"Hello from the second method\"\n\n    @listen(or_(start_method, second_method))\n    def logger(self, result):\n        print(f\"Logger: {result}\")\n\n\nasync def main():\n    flow = OrExampleFlow()\n    await flow.kickoff()\n\n\nasyncio.run(main())\n</code></pre> <p>When you run this Flow, the <code>logger</code> method will be triggered by the output of either the <code>start_method</code> or the <code>second_method</code>. The <code>or_</code> function is to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.</p> <p>The output of the Flow will be:</p> <pre><code>Logger: Hello from the start method\nLogger: Hello from the second method\n</code></pre>"},{"location":"core-concepts/Flows/#and","title":"and","text":"<p>The <code>and_</code> function in Flows allows you to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.</p> <pre><code>import asyncio\nfrom crewai.flow.flow import Flow, and_, listen, start\n\nclass AndExampleFlow(Flow):\n\n    @start()\n    def start_method(self):\n        self.state[\"greeting\"] = \"Hello from the start method\"\n\n    @listen(start_method)\n    def second_method(self):\n        self.state[\"joke\"] = \"What do computers eat? Microchips.\"\n\n    @listen(and_(start_method, second_method))\n    def logger(self):\n        print(\"---- Logger ----\")\n        print(self.state)\n\n\nasync def main():\n    flow = AndExampleFlow()\n    await flow.kickoff()\n\n\nasyncio.run(main())\n</code></pre> <p>When you run this Flow, the <code>logger</code> method will be triggered only when both the <code>start_method</code> and the <code>second_method</code> emit an output. The <code>and_</code> function is used to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.</p> <p>The output of the Flow will be:</p> <pre><code>---- Logger ----\n{'greeting': 'Hello from the start method', 'joke': 'What do computers eat? Microchips.'}\n</code></pre>"},{"location":"core-concepts/Flows/#router","title":"Router","text":"<p>The <code>@router()</code> decorator in Flows allows you to define conditional routing logic based on the output of a method. You can specify different routes based on the output of the method, allowing you to control the flow of execution dynamically.</p> <pre><code>import asyncio\nimport random\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\n\nclass ExampleState(BaseModel):\n    success_flag: bool = False\n\nclass RouterFlow(Flow[ExampleState]):\n\n    @start()\n    def start_method(self):\n        print(\"Starting the structured flow\")\n        random_boolean = random.choice([True, False])\n        self.state.success_flag = random_boolean\n\n    @router(start_method)\n    def second_method(self):\n        if self.state.success_flag:\n            return \"success\"\n        else:\n            return \"failed\"\n\n    @listen(\"success\")\n    def third_method(self):\n        print(\"Third method running\")\n\n    @listen(\"failed\")\n    def fourth_method(self):\n        print(\"Fourth method running\")\n\n\nasync def main():\n    flow = RouterFlow()\n    await flow.kickoff()\n\n\nasyncio.run(main())\n</code></pre> <p>In the above example, the <code>start_method</code> generates a random boolean value and sets it in the state. The <code>second_method</code> uses the <code>@router()</code> decorator to define conditional routing logic based on the value of the boolean. If the boolean is <code>True</code>, the method returns <code>\"success\"</code>, and if it is <code>False</code>, the method returns <code>\"failed\"</code>. The <code>third_method</code> and <code>fourth_method</code> listen to the output of the <code>second_method</code> and execute based on the returned value.</p> <p>When you run this Flow, the output will change based on the random boolean value generated by the <code>start_method</code>, but you should see an output similar to the following:</p> <pre><code>Starting the structured flow\nThird method running\n</code></pre>"},{"location":"core-concepts/Flows/#adding-crews-to-flows","title":"Adding Crews to Flows","text":"<p>Creating a flow with multiple crews in CrewAI is straightforward. You can generate a new CrewAI project that includes all the scaffolding needed to create a flow with multiple crews by running the following command:</p> <pre><code>crewai create flow name_of_flow\n</code></pre> <p>This command will generate a new CrewAI project with the necessary folder structure. The generated project includes a prebuilt crew called <code>poem_crew</code> that is already working. You can use this crew as a template by copying, pasting, and editing it to create other crews.</p>"},{"location":"core-concepts/Flows/#folder-structure","title":"Folder Structure","text":"<p>After running the <code>crewai create flow name_of_flow</code> command, you will see a folder structure similar to the following:</p> <pre><code>name_of_flow/\n\u251c\u2500\u2500 crews/\n\u2502   \u2514\u2500\u2500 poem_crew/\n\u2502       \u251c\u2500\u2500 config/\n\u2502       \u2502   \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2514\u2500\u2500 tasks.yaml\n\u2502       \u251c\u2500\u2500 poem_crew.py\n\u251c\u2500\u2500 tools/\n\u2502   \u2514\u2500\u2500 custom_tool.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 .gitignore\n</code></pre>"},{"location":"core-concepts/Flows/#building-your-crews","title":"Building Your Crews","text":"<p>In the <code>crews</code> folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the <code>poem_crew</code> folder contains:</p> <ul> <li><code>config/agents.yaml</code>: Defines the agents for the crew.</li> <li><code>config/tasks.yaml</code>: Defines the tasks for the crew.</li> <li><code>poem_crew.py</code>: Contains the crew definition, including agents, tasks, and the crew itself.</li> </ul> <p>You can copy, paste, and edit the <code>poem_crew</code> to create other crews.</p>"},{"location":"core-concepts/Flows/#connecting-crews-in-mainpy","title":"Connecting Crews in <code>main.py</code>","text":"<p>The <code>main.py</code> file is where you create your flow and connect the crews together. You can define your flow by using the <code>Flow</code> class and the decorators <code>@start</code> and <code>@listen</code> to specify the flow of execution.</p> <p>Here's an example of how you can connect the <code>poem_crew</code> in the <code>main.py</code> file:</p> <pre><code>#!/usr/bin/env python\nimport asyncio\nfrom random import randint\n\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\n\nclass PoemState(BaseModel):\n    sentence_count: int = 1\n    poem: str = \"\"\n\nclass PoemFlow(Flow[PoemState]):\n\n    @start()\n    def generate_sentence_count(self):\n        print(\"Generating sentence count\")\n        # Generate a number between 1 and 5\n        self.state.sentence_count = randint(1, 5)\n\n    @listen(generate_sentence_count)\n    def generate_poem(self):\n        print(\"Generating poem\")\n        poem_crew = PoemCrew().crew()\n        result = poem_crew.kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n\n        print(\"Poem generated\", result.raw)\n        self.state.poem = result.raw\n\n    @listen(generate_poem)\n    def save_poem(self):\n        print(\"Saving poem\")\n        with open(\"poem.txt\", \"w\") as f:\n            f.write(self.state.poem)\n\nasync def run():\n    \"\"\"\n    Run the flow.\n    \"\"\"\n    poem_flow = PoemFlow()\n    await poem_flow.kickoff()\n\ndef main():\n    asyncio.run(run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>In this example, the <code>PoemFlow</code> class defines a flow that generates a sentence count, uses the <code>PoemCrew</code> to generate a poem, and then saves the poem to a file. The flow is kicked off by calling the <code>kickoff()</code> method.</p>"},{"location":"core-concepts/Flows/#next-steps","title":"Next Steps","text":"<p>If you're interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example:</p> <ol> <li> <p>Email Auto Responder Flow: This example demonstrates an infinite loop where a background job continually runs to automate email responses. It's a great use case for tasks that need to be performed repeatedly without manual intervention. View Example</p> </li> <li> <p>Lead Score Flow: This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It's an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. View Example</p> </li> <li> <p>Write a Book Flow: This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. View Example</p> </li> <li> <p>Meeting Assistant Flow: This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It's a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. View Example</p> </li> </ol> <p>By exploring these examples, you can gain insights into how to leverage CrewAI Flows for various use cases, from automating repetitive tasks to managing complex, multi-step processes with dynamic decision-making and human feedback.</p>"},{"location":"core-concepts/LLMs/","title":"Large Language Models (LLMs) in crewAI","text":""},{"location":"core-concepts/LLMs/#introduction","title":"Introduction","text":"<p>Large Language Models (LLMs) are the backbone of intelligent agents in the crewAI framework. This guide will help you understand, configure, and optimize LLM usage for your crewAI projects.</p>"},{"location":"core-concepts/LLMs/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Key Concepts</li> <li>Configuring LLMs for Agents</li> <li>1. Default Configuration</li> <li>2. String Identifier</li> <li>3. LLM Instance</li> <li>4. Custom LLM Objects</li> <li>Connecting to OpenAI-Compatible LLMs</li> <li>LLM Configuration Options</li> <li>Using Ollama (Local LLMs)</li> <li>Changing the Base API URL</li> <li>Best Practices</li> <li>Troubleshooting</li> </ul>"},{"location":"core-concepts/LLMs/#key-concepts","title":"Key Concepts","text":"<ul> <li>LLM: Large Language Model, the AI powering agent intelligence</li> <li>Agent: A crewAI entity that uses an LLM to perform tasks</li> <li>Provider: A service that offers LLM capabilities (e.g., OpenAI, Anthropic, Ollama, more providers)</li> </ul>"},{"location":"core-concepts/LLMs/#configuring-llms-for-agents","title":"Configuring LLMs for Agents","text":"<p>crewAI offers flexible options for setting up LLMs:</p>"},{"location":"core-concepts/LLMs/#1-default-configuration","title":"1. Default Configuration","text":"<p>By default, crewAI uses the <code>gpt-4o-mini</code> model. It uses environment variables if no LLM is specified: - <code>OPENAI_MODEL_NAME</code> (defaults to \"gpt-4o-mini\" if not set) - <code>OPENAI_API_BASE</code> - <code>OPENAI_API_KEY</code></p>"},{"location":"core-concepts/LLMs/#2-string-identifier","title":"2. String Identifier","text":"<pre><code>agent = Agent(llm=\"gpt-4o\", ...)\n</code></pre>"},{"location":"core-concepts/LLMs/#3-llm-instance","title":"3. LLM Instance","text":"<p>List of more providers. <pre><code>from crewai import LLM\n\nllm = LLM(model=\"gpt-4\", temperature=0.7)\nagent = Agent(llm=llm, ...)\n</code></pre></p>"},{"location":"core-concepts/LLMs/#4-custom-llm-objects","title":"4. Custom LLM Objects","text":"<p>Pass a custom LLM implementation or object from another library.</p>"},{"location":"core-concepts/LLMs/#connecting-to-openai-compatible-llms","title":"Connecting to OpenAI-Compatible LLMs","text":"<p>You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:</p> <ol> <li> <p>Using environment variables: <pre><code>import os\n\nos.environ[\"OPENAI_API_KEY\"] = \"your-api-key\"\nos.environ[\"OPENAI_API_BASE\"] = \"https://api.your-provider.com/v1\"\n</code></pre></p> </li> <li> <p>Using LLM class attributes: <pre><code>llm = LLM(\n    model=\"custom-model-name\",\n    api_key=\"your-api-key\",\n    base_url=\"https://api.your-provider.com/v1\"\n)\nagent = Agent(llm=llm, ...)\n</code></pre></p> </li> </ol>"},{"location":"core-concepts/LLMs/#llm-configuration-options","title":"LLM Configuration Options","text":"<p>When configuring an LLM for your agent, you have access to a wide range of parameters:</p> Parameter Type Description <code>model</code> str The name of the model to use (e.g., \"gpt-4\", \"gpt-3.5-turbo\", \"ollama/llama3.1\", more providers) <code>timeout</code> float, int Maximum time (in seconds) to wait for a response <code>temperature</code> float Controls randomness in output (0.0 to 1.0) <code>top_p</code> float Controls diversity of output (0.0 to 1.0) <code>n</code> int Number of completions to generate <code>stop</code> str, List[str] Sequence(s) to stop generation <code>max_tokens</code> int Maximum number of tokens to generate <code>presence_penalty</code> float Penalizes new tokens based on their presence in the text so far <code>frequency_penalty</code> float Penalizes new tokens based on their frequency in the text so far <code>logit_bias</code> Dict[int, float] Modifies likelihood of specified tokens appearing in the completion <code>response_format</code> Dict[str, Any] Specifies the format of the response (e.g., {\"type\": \"json_object\"}) <code>seed</code> int Sets a random seed for deterministic results <code>logprobs</code> bool Whether to return log probabilities of the output tokens <code>top_logprobs</code> int Number of most likely tokens to return the log probabilities for <code>base_url</code> str The base URL for the API endpoint <code>api_version</code> str The version of the API to use <code>api_key</code> str Your API key for authentication <p>Example: <pre><code>llm = LLM(\n    model=\"gpt-4\",\n    temperature=0.8,\n    max_tokens=150,\n    top_p=0.9,\n    frequency_penalty=0.1,\n    presence_penalty=0.1,\n    stop=[\"END\"],\n    seed=42,\n    base_url=\"https://api.openai.com/v1\",\n    api_key=\"your-api-key-here\"\n)\nagent = Agent(llm=llm, ...)\n</code></pre></p>"},{"location":"core-concepts/LLMs/#using-ollama-local-llms","title":"Using Ollama (Local LLMs)","text":"<p>crewAI supports using Ollama for running open-source models locally:</p> <ol> <li>Install Ollama: ollama.ai</li> <li>Run a model: <code>ollama run llama2</code></li> <li>Configure agent: <pre><code>agent = Agent(\n    llm=LLM(model=\"ollama/llama3.1\", base_url=\"http://localhost:11434\"),\n    ...\n)\n</code></pre></li> </ol>"},{"location":"core-concepts/LLMs/#changing-the-base-api-url","title":"Changing the Base API URL","text":"<p>You can change the base API URL for any LLM provider by setting the <code>base_url</code> parameter:</p> <pre><code>llm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)\n</code></pre> <p>This is particularly useful when working with OpenAI-compatible APIs or when you need to specify a different endpoint for your chosen provider.</p>"},{"location":"core-concepts/LLMs/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the right model: Balance capability and cost.</li> <li>Optimize prompts: Clear, concise instructions improve output.</li> <li>Manage tokens: Monitor and limit token usage for efficiency.</li> <li>Use appropriate temperature: Lower for factual tasks, higher for creative ones.</li> <li>Implement error handling: Gracefully manage API errors and rate limits.</li> </ol>"},{"location":"core-concepts/LLMs/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>API Errors: Check your API key, network connection, and rate limits.</li> <li>Unexpected Outputs: Refine your prompts and adjust temperature or top_p.</li> <li>Performance Issues: Consider using a more powerful model or optimizing your queries.</li> <li>Timeout Errors: Increase the <code>timeout</code> parameter or optimize your input.</li> </ul>"},{"location":"core-concepts/Memory/","title":"crewAI Memory Systems","text":""},{"location":"core-concepts/Memory/#introduction-to-memory-systems-in-crewai","title":"Introduction to Memory Systems in crewAI","text":"<p>Enhancing Agent Intelligence</p> <p>The crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents. This system comprises short-term memory, long-term memory, entity memory, and contextual memory, each serving a unique purpose in aiding agents to remember, reason, and learn from past interactions.</p>"},{"location":"core-concepts/Memory/#memory-system-components","title":"Memory System Components","text":"Component Description Short-Term Memory Temporarily stores recent interactions and outcomes using <code>RAG</code>, enabling agents to recall and utilize information relevant to their current context during the current executions. Long-Term Memory Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time. Entity Memory Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Uses <code>RAG</code> for storing entity information. Contextual Memory Maintains the context of interactions by combining <code>ShortTermMemory</code>, <code>LongTermMemory</code>, and <code>EntityMemory</code>, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation."},{"location":"core-concepts/Memory/#how-memory-systems-empower-agents","title":"How Memory Systems Empower Agents","text":"<ol> <li> <p>Contextual Awareness: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses.</p> </li> <li> <p>Experience Accumulation: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving.</p> </li> <li> <p>Entity Understanding: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.</p> </li> </ol>"},{"location":"core-concepts/Memory/#implementing-memory-in-your-crew","title":"Implementing Memory in Your Crew","text":"<p>When configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform. By default, the memory system is disabled, and you can ensure it is active by setting <code>memory=True</code> in the crew configuration. The memory will use OpenAI embeddings by default, but you can change it by setting <code>embedder</code> to a different model. It's also possible to initialize the memory instance with your own instance.</p> <p>The 'embedder' only applies to Short-Term Memory which uses Chroma for RAG using the EmbedChain package. The Long-Term Memory uses SQLite3 to store task results. Currently, there is no way to override these storage implementations. The data storage files are saved into a platform-specific location found using the appdirs package, and the name of the project can be overridden using the CREWAI_STORAGE_DIR environment variable.</p>"},{"location":"core-concepts/Memory/#example-configuring-memory-for-a-crew","title":"Example: Configuring Memory for a Crew","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)\n</code></pre>"},{"location":"core-concepts/Memory/#example-use-custom-memory-instances-eg-faiss-as-the-vectordb","title":"Example: Use Custom Memory Instances e.g FAISS as the VectorDB","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=\"Process.sequential\",\n    memory=True,\n    long_term_memory=EnhanceLongTermMemory(\n        storage=LTMSQLiteStorage(\n            db_path=\"/my_data_dir/my_crew1/long_term_memory_storage.db\"\n        )\n    ),\n    short_term_memory=EnhanceShortTermMemory(\n        storage=CustomRAGStorage(\n            crew_name=\"my_crew\",\n            storage_type=\"short_term\",\n            data_dir=\"//my_data_dir\",\n            model=embedder[\"model\"],\n            dimension=embedder[\"dimension\"],\n        ),\n    ),\n    entity_memory=EnhanceEntityMemory(\n        storage=CustomRAGStorage(\n            crew_name=\"my_crew\",\n            storage_type=\"entities\",\n            data_dir=\"//my_data_dir\",\n            model=embedder[\"model\"],\n            dimension=embedder[\"dimension\"],\n        ),\n    ),\n    verbose=True,\n)\n</code></pre>"},{"location":"core-concepts/Memory/#additional-embedding-providers","title":"Additional Embedding Providers","text":""},{"location":"core-concepts/Memory/#using-openai-embeddings-already-default","title":"Using OpenAI embeddings (already default)","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"openai\",\n        \"config\": {\n            \"model\": 'text-embedding-3-small'\n        }\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-google-ai-embeddings","title":"Using Google AI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"google\",\n        \"config\": {\n            \"model\": 'models/embedding-001',\n            \"task_type\": \"retrieval_document\",\n            \"title\": \"Embeddings for Embedchain\"\n        }\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-azure-openai-embeddings","title":"Using Azure OpenAI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"azure_openai\",\n        \"config\": {\n            \"model\": 'text-embedding-ada-002',\n            \"deployment_name\": \"your_embedding_model_deployment_name\"\n        }\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-gpt4all-embeddings","title":"Using GPT4ALL embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"gpt4all\"\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-vertex-ai-embeddings","title":"Using Vertex AI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"vertexai\",\n        \"config\": {\n            \"model\": 'textembedding-gecko'\n        }\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-cohere-embeddings","title":"Using Cohere embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True,\n    embedder={\n        \"provider\": \"cohere\",\n        \"config\": {\n            \"model\": \"embed-english-v3.0\",\n            \"vector_dimension\": 1024\n        }\n    }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#resetting-memory","title":"Resetting Memory","text":"<pre><code>crewai reset_memories [OPTIONS]\n</code></pre>"},{"location":"core-concepts/Memory/#resetting-memory-options","title":"Resetting Memory Options","text":"<ul> <li><code>-l, --long</code></li> <li>Description: Reset LONG TERM memory.</li> <li>Type: Flag (boolean)</li> <li> <p>Default: False</p> </li> <li> <p><code>-s, --short</code></p> </li> <li>Description: Reset SHORT TERM memory.</li> <li>Type: Flag (boolean)</li> <li> <p>Default: False</p> </li> <li> <p><code>-e, --entities</code></p> </li> <li>Description: Reset ENTITIES memory.</li> <li>Type: Flag (boolean)</li> <li> <p>Default: False</p> </li> <li> <p><code>-k, --kickoff-outputs</code></p> </li> <li>Description: Reset LATEST KICKOFF TASK OUTPUTS.</li> <li>Type: Flag (boolean)</li> <li> <p>Default: False</p> </li> <li> <p><code>-a, --all</code></p> </li> <li>Description: Reset ALL memories.</li> <li>Type: Flag (boolean)</li> <li>Default: False</li> </ul>"},{"location":"core-concepts/Memory/#benefits-of-using-crewais-memory-system","title":"Benefits of Using crewAI's Memory System","text":"<ul> <li>Adaptive Learning: Crews become more efficient over time, adapting to new information and refining their approach to tasks.</li> <li>Enhanced Personalization: Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences.</li> <li>Improved Problem Solving: Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.</li> </ul>"},{"location":"core-concepts/Memory/#getting-started","title":"Getting Started","text":"<p>Integrating crewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations, you can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability.</p>"},{"location":"core-concepts/Pipeline/","title":"crewAI Pipelines","text":""},{"location":"core-concepts/Pipeline/#what-is-a-pipeline","title":"What is a Pipeline?","text":"<p>A pipeline in crewAI represents a structured workflow that allows for the sequential or parallel execution of multiple crews. It provides a way to organize complex processes involving multiple stages, where the output of one stage can serve as input for subsequent stages.</p>"},{"location":"core-concepts/Pipeline/#key-terminology","title":"Key Terminology","text":"<p>Understanding the following terms is crucial for working effectively with pipelines:</p> <ul> <li>Stage: A distinct part of the pipeline, which can be either sequential (a single crew) or parallel (multiple crews executing concurrently).</li> <li>Kickoff: A specific execution of the pipeline for a given set of inputs, representing a single instance of processing through the pipeline.</li> <li>Branch: Parallel executions within a stage (e.g., concurrent crew operations).</li> <li>Trace: The journey of an individual input through the entire pipeline, capturing the path and transformations it undergoes.</li> </ul> <p>Example pipeline structure:</p> <pre><code>crew1 &gt;&gt; [crew2, crew3] &gt;&gt; crew4\n</code></pre> <p>This represents a pipeline with three stages:</p> <ol> <li>A sequential stage (crew1)</li> <li>A parallel stage with two branches (crew2 and crew3 executing concurrently)</li> <li>Another sequential stage (crew4)</li> </ol> <p>Each input creates its own kickoff, flowing through all stages of the pipeline. Multiple kickoffs can be processed concurrently, each following the defined pipeline structure.</p>"},{"location":"core-concepts/Pipeline/#pipeline-attributes","title":"Pipeline Attributes","text":"Attribute Parameters Description Stages <code>stages</code> A list of <code>PipelineStage</code> (crews, lists of crews, or routers) representing the stages to be executed in sequence."},{"location":"core-concepts/Pipeline/#creating-a-pipeline","title":"Creating a Pipeline","text":"<p>When creating a pipeline, you define a series of stages, each consisting of either a single crew or a list of crews for parallel execution. The pipeline ensures that each stage is executed in order, with the output of one stage feeding into the next.</p>"},{"location":"core-concepts/Pipeline/#example-assembling-a-pipeline","title":"Example: Assembling a Pipeline","text":"<pre><code>from crewai import Crew, Process, Pipeline\n\n# Define your crews\nresearch_crew = Crew(\n    agents=[researcher],\n    tasks=[research_task],\n    process=Process.sequential\n)\n\nanalysis_crew = Crew(\n    agents=[analyst],\n    tasks=[analysis_task],\n    process=Process.sequential\n)\n\nwriting_crew = Crew(\n    agents=[writer],\n    tasks=[writing_task],\n    process=Process.sequential\n)\n\n# Assemble the pipeline\nmy_pipeline = Pipeline(\n    stages=[research_crew, analysis_crew, writing_crew]\n)\n</code></pre>"},{"location":"core-concepts/Pipeline/#pipeline-methods","title":"Pipeline Methods","text":"Method Description kickoff Executes the pipeline, processing all stages and returning the results. This method initiates one or more kickoffs through the pipeline, handling the flow of data between stages. process_runs Runs the pipeline for each input provided, handling the flow and transformation of data between stages."},{"location":"core-concepts/Pipeline/#pipeline-output","title":"Pipeline Output","text":"<p>Understanding Pipeline Outputs</p> <p>The output of a pipeline in the crewAI framework is encapsulated within the <code>PipelineKickoffResult</code> class. This class provides a structured way to access the results of the pipeline's execution, including various formats such as raw strings, JSON, and Pydantic models.</p>"},{"location":"core-concepts/Pipeline/#pipeline-output-attributes","title":"Pipeline Output Attributes","text":"Attribute Parameters Type Description ID <code>id</code> <code>UUID4</code> A unique identifier for the pipeline output. Run Results <code>run_results</code> <code>List[PipelineRunResult]</code> A list of <code>PipelineRunResult</code> objects, each representing the output of a single run through the pipeline."},{"location":"core-concepts/Pipeline/#pipeline-output-methods","title":"Pipeline Output Methods","text":"Method/Property Description add_run_result Adds a <code>PipelineRunResult</code> to the list of run results."},{"location":"core-concepts/Pipeline/#pipeline-run-result-attributes","title":"Pipeline Run Result Attributes","text":"Attribute Parameters Type Description ID <code>id</code> <code>UUID4</code> A unique identifier for the run result. Raw <code>raw</code> <code>str</code> The raw output of the final stage in the pipeline kickoff. Pydantic <code>pydantic</code> <code>Any</code> A Pydantic model object representing the structured output of the final stage, if applicable. JSON Dict <code>json_dict</code> <code>Union[Dict[str, Any], None]</code> A dictionary representing the JSON output of the final stage, if applicable. Token Usage <code>token_usage</code> <code>Dict[str, UsageMetrics]</code> A summary of token usage across all stages of the pipeline kickoff. Trace <code>trace</code> <code>List[Any]</code> A trace of the journey of inputs through the pipeline kickoff. Crews Outputs <code>crews_outputs</code> <code>List[CrewOutput]</code> A list of <code>CrewOutput</code> objects, representing the outputs from each crew in the pipeline kickoff."},{"location":"core-concepts/Pipeline/#pipeline-run-result-methods-and-properties","title":"Pipeline Run Result Methods and Properties","text":"Method/Property Description json Returns the JSON string representation of the run result if the output format of the final task is JSON. to_dict Converts the JSON and Pydantic outputs to a dictionary. str Returns the string representation of the run result, prioritizing Pydantic, then JSON, then raw."},{"location":"core-concepts/Pipeline/#accessing-pipeline-outputs","title":"Accessing Pipeline Outputs","text":"<p>Once a pipeline has been executed, its output can be accessed through the <code>PipelineOutput</code> object returned by the <code>process_runs</code> method. The <code>PipelineOutput</code> class provides access to individual <code>PipelineRunResult</code> objects, each representing a single run through the pipeline.</p>"},{"location":"core-concepts/Pipeline/#example","title":"Example","text":"<pre><code># Define input data for the pipeline\ninput_data = [{\"initial_query\": \"Latest advancements in AI\"}, {\"initial_query\": \"Future of robotics\"}]\n\n# Execute the pipeline\npipeline_output = await my_pipeline.process_runs(input_data)\n\n# Access the results\nfor run_result in pipeline_output.run_results:\n    print(f\"Run ID: {run_result.id}\")\n    print(f\"Final Raw Output: {run_result.raw}\")\n    if run_result.json_dict:\n        print(f\"JSON Output: {json.dumps(run_result.json_dict, indent=2)}\")\n    if run_result.pydantic:\n        print(f\"Pydantic Output: {run_result.pydantic}\")\n    print(f\"Token Usage: {run_result.token_usage}\")\n    print(f\"Trace: {run_result.trace}\")\n    print(\"Crew Outputs:\")\n    for crew_output in run_result.crews_outputs:\n        print(f\"  Crew: {crew_output.raw}\")\n    print(\"\\n\")\n</code></pre> <p>This example demonstrates how to access and work with the pipeline output, including individual run results and their associated data.</p>"},{"location":"core-concepts/Pipeline/#using-pipelines","title":"Using Pipelines","text":"<p>Pipelines are particularly useful for complex workflows that involve multiple stages of processing, analysis, or content generation. They allow you to:</p> <ol> <li>Sequence Operations: Execute crews in a specific order, ensuring that the output of one crew is available as input to the next.</li> <li>Parallel Processing: Run multiple crews concurrently within a stage for increased efficiency.</li> <li>Manage Complex Workflows: Break down large tasks into smaller, manageable steps executed by specialized crews.</li> </ol>"},{"location":"core-concepts/Pipeline/#example-running-a-pipeline","title":"Example: Running a Pipeline","text":"<pre><code># Define input data for the pipeline\ninput_data = [{\"initial_query\": \"Latest advancements in AI\"}]\n\n# Execute the pipeline, initiating a run for each input\nresults = await my_pipeline.process_runs(input_data)\n\n# Access the results\nfor result in results:\n    print(f\"Final Output: {result.raw}\")\n    print(f\"Token Usage: {result.token_usage}\")\n    print(f\"Trace: {result.trace}\")  # Shows the path of the input through all stages\n</code></pre>"},{"location":"core-concepts/Pipeline/#advanced-features","title":"Advanced Features","text":""},{"location":"core-concepts/Pipeline/#parallel-execution-within-stages","title":"Parallel Execution within Stages","text":"<p>You can define parallel execution within a stage by providing a list of crews, creating multiple branches:</p> <pre><code>parallel_analysis_crew = Crew(agents=[financial_analyst], tasks=[financial_analysis_task])\nmarket_analysis_crew = Crew(agents=[market_analyst], tasks=[market_analysis_task])\n\nmy_pipeline = Pipeline(\n    stages=[\n        research_crew,\n        [parallel_analysis_crew, market_analysis_crew],  # Parallel execution (branching)\n        writing_crew\n    ]\n)\n</code></pre>"},{"location":"core-concepts/Pipeline/#routers-in-pipelines","title":"Routers in Pipelines","text":"<p>Routers are a powerful feature in crewAI pipelines that allow for dynamic decision-making and branching within your workflow. They enable you to direct the flow of execution based on specific conditions or criteria, making your pipelines more flexible and adaptive.</p>"},{"location":"core-concepts/Pipeline/#what-is-a-router","title":"What is a Router?","text":"<p>A router in crewAI is a special component that can be included as a stage in your pipeline. It evaluates the input data and determines which path the execution should take next. This allows for conditional branching in your pipeline, where different crews or sub-pipelines can be executed based on the router's decision.</p>"},{"location":"core-concepts/Pipeline/#key-components-of-a-router","title":"Key Components of a Router","text":"<ol> <li>Routes: A dictionary of named routes, each associated with a condition and a pipeline to execute if the condition is met.</li> <li>Default Route: A fallback pipeline that is executed if none of the defined route conditions are met.</li> </ol>"},{"location":"core-concepts/Pipeline/#creating-a-router","title":"Creating a Router","text":"<p>Here's an example of how to create a router:</p> <pre><code>from crewai import Router, Route, Pipeline, Crew, Agent, Task\n\n# Define your agents\nclassifier = Agent(name=\"Classifier\", role=\"Email Classifier\")\nurgent_handler = Agent(name=\"Urgent Handler\", role=\"Urgent Email Processor\")\nnormal_handler = Agent(name=\"Normal Handler\", role=\"Normal Email Processor\")\n\n# Define your tasks\nclassify_task = Task(description=\"Classify the email based on its content and metadata.\")\nurgent_task = Task(description=\"Process and respond to urgent email quickly.\")\nnormal_task = Task(description=\"Process and respond to normal email thoroughly.\")\n\n# Define your crews\nclassification_crew = Crew(agents=[classifier], tasks=[classify_task]) # classify email between high and low urgency 1-10\nurgent_crew = Crew(agents=[urgent_handler], tasks=[urgent_task])\nnormal_crew = Crew(agents=[normal_handler], tasks=[normal_task])\n\n# Create pipelines for different urgency levels\nurgent_pipeline = Pipeline(stages=[urgent_crew])\nnormal_pipeline = Pipeline(stages=[normal_crew])\n\n# Create a router\nemail_router = Router(\n    routes={\n        \"high_urgency\": Route(\n            condition=lambda x: x.get(\"urgency_score\", 0) &gt; 7,\n            pipeline=urgent_pipeline\n        ),\n        \"low_urgency\": Route(\n            condition=lambda x: x.get(\"urgency_score\", 0) &lt;= 7,\n            pipeline=normal_pipeline\n        )\n    },\n    default=Pipeline(stages=[normal_pipeline])  # Default to just normal if no urgency score\n)\n\n# Use the router in a main pipeline\nmain_pipeline = Pipeline(stages=[classification_crew, email_router])\n\ninputs = [{\"email\": \"...\"}, {\"email\": \"...\"}]  # List of email data\n\nmain_pipeline.kickoff(inputs=inputs=inputs)\n</code></pre> <p>In this example, the router decides between an urgent pipeline and a normal pipeline based on the urgency score of the email. If the urgency score is greater than 7, it routes to the urgent pipeline; otherwise, it uses the normal pipeline. If the input doesn't include an urgency score, it defaults to just the classification crew.</p>"},{"location":"core-concepts/Pipeline/#benefits-of-using-routers","title":"Benefits of Using Routers","text":"<ol> <li>Dynamic Workflow: Adapt your pipeline's behavior based on input characteristics or intermediate results.</li> <li>Efficiency: Route urgent tasks to quicker processes, reserving more thorough pipelines for less time-sensitive inputs.</li> <li>Flexibility: Easily modify or extend your pipeline's logic without changing the core structure.</li> <li>Scalability: Handle a wide range of email types and urgency levels with a single pipeline structure.</li> </ol>"},{"location":"core-concepts/Pipeline/#error-handling-and-validation","title":"Error Handling and Validation","text":"<p>The <code>Pipeline</code> class includes validation mechanisms to ensure the robustness of the pipeline structure:</p> <ul> <li>Validates that stages contain only Crew instances or lists of Crew instances.</li> <li>Prevents double nesting of stages to maintain a clear structure.</li> </ul>"},{"location":"core-concepts/Planning/","title":"crewAI Planning","text":""},{"location":"core-concepts/Planning/#introduction","title":"Introduction","text":"<p>The planning feature in CrewAI allows you to add planning capability to your crew. When enabled, before each Crew iteration, all Crew information is sent to an AgentPlanner that will plan the tasks step by step, and this plan will be added to each task description.</p>"},{"location":"core-concepts/Planning/#using-the-planning-feature","title":"Using the Planning Feature","text":"<p>Getting started with the planning feature is very easy, the only step required is to add <code>planning=True</code> to your Crew:</p> <pre><code>from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with planning capabilities\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n)\n</code></pre> <p>From this point on, your crew will have planning enabled, and the tasks will be planned before each iteration.</p>"},{"location":"core-concepts/Planning/#planning-llm","title":"Planning LLM","text":"<p>Now you can define the LLM that will be used to plan the tasks. You can use any ChatOpenAI LLM model available.</p> <pre><code>from crewai import Crew, Agent, Task, Process\nfrom langchain_openai import ChatOpenAI\n\n# Assemble your crew with planning capabilities and custom LLM\nmy_crew = Crew(\n    agents=self.agents,\n    tasks=self.tasks,\n    process=Process.sequential,\n    planning=True,\n    planning_llm=ChatOpenAI(model=\"gpt-4o\")\n)\n</code></pre>"},{"location":"core-concepts/Planning/#example","title":"Example","text":"<p>When running the base case example, you will see something like the following output, which represents the output of the AgentPlanner responsible for creating the step-by-step logic to add to the Agents' tasks.</p> <p>``` [2024-07-15 16:49:11][INFO]: Planning the crew execution Step-by-Step Plan for Task Execution</p> <p>Task Number 1: Conduct a thorough research about AI LLMs</p> <p>Agent: AI LLMs Senior Data Researcher</p> <p>Agent Goal: Uncover cutting-edge developments in AI LLMs</p> <p>Task Expected Output: A list with 10 bullet points of the most relevant information about AI LLMs</p> <p>Task Tools: None specified</p> <p>Agent Tools: None specified</p> <p>Step-by-Step Plan:</p> <ol> <li>Define Research Scope:</li> <li> <p>Determine the specific areas of AI LLMs to focus on, such as advancements in architecture, use cases, ethical considerations, and performance metrics.</p> </li> <li> <p>Identify Reliable Sources:</p> </li> <li> <p>List reputable sources for AI research, including academic journals, industry reports, conferences (e.g., NeurIPS, ACL), AI research labs (e.g., OpenAI, Google AI), and online databases (e.g., IEEE Xplore, arXiv).</p> </li> <li> <p>Collect Data:</p> </li> <li>Search for the latest papers, articles, and reports published in 2023 and early 2024.</li> <li> <p>Use keywords like \"Large Language Models 2024\", \"AI LLM advancements\", \"AI ethics 2024\", etc.</p> </li> <li> <p>Analyze Findings:</p> </li> <li>Read and summarize the key points from each source.</li> <li> <p>Highlight new techniques, models, and applications introduced in the past year.</p> </li> <li> <p>Organize Information:</p> </li> <li>Categorize the information into relevant topics (e.g., new architectures, ethical implications, real-world applications).</li> <li> <p>Ensure each bullet point is concise but informative.</p> </li> <li> <p>Create the List:</p> </li> <li>Compile the 10 most relevant pieces of information into a bullet point list.</li> <li>Review the list to ensure clarity and relevance.</li> </ol> <p>Expected Output: A list with 10 bullet points of the most relevant information about AI LLMs.</p> <p>Task Number 2: Review the context you got and expand each topic into a full section for a report</p> <p>Agent: AI LLMs Reporting Analyst</p> <p>Agent Goal: Create detailed reports based on AI LLMs data analysis and research findings</p> <p>Task Expected Output: A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'</p> <p>Task Tools: None specified</p> <p>Agent Tools: None specified</p> <p>Step-by-Step Plan:</p> <ol> <li>Review the Bullet Points:</li> <li> <p>Carefully read through the list of 10 bullet points provided by the AI LLMs Senior Data Researcher.</p> </li> <li> <p>Outline the Report:</p> </li> <li>Create an outline with each bullet point as a main section heading.</li> <li> <p>Plan sub-sections under each main heading to cover different aspects of the topic.</p> </li> <li> <p>Research Further Details:</p> </li> <li>For each bullet point, conduct additional research if necessary to gather more detailed information.</li> <li> <p>Look for case studies, examples, and statistical data to support each section.</p> </li> <li> <p>Write Detailed Sections:</p> </li> <li>Expand each bullet point into a comprehensive section.</li> <li>Ensure each section includes an introduction, detailed explanation, examples, and a conclusion.</li> <li> <p>Use markdown formatting for headings, subheadings, lists, and emphasis.</p> </li> <li> <p>Review and Edit:</p> </li> <li>Proofread the report for clarity, coherence, and correctness.</li> <li>Make sure the report flows logically from one section to the next.</li> <li> <p>Format the report according to markdown standards.</p> </li> <li> <p>Finalize the Report:</p> </li> <li>Ensure the report is complete with all sections expanded and detailed.</li> <li>Double-check formatting and make any necessary adjustments.</li> </ol> <p>Expected Output: A fully fledged report with the main topics, each with a full section of information. Formatted as markdown without '```'.</p>"},{"location":"core-concepts/Processes/","title":"Managing Processes in CrewAI","text":""},{"location":"core-concepts/Processes/#understanding-processes","title":"Understanding Processes","text":"<p>Core Concept</p> <p>In CrewAI, processes orchestrate the execution of tasks by agents, akin to project management in human teams. These processes ensure tasks are distributed and executed efficiently, in alignment with a predefined strategy.</p>"},{"location":"core-concepts/Processes/#process-implementations","title":"Process Implementations","text":"<ul> <li>Sequential: Executes tasks sequentially, ensuring tasks are completed in an orderly progression.</li> <li>Hierarchical: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (<code>manager_llm</code>) or a custom manager agent (<code>manager_agent</code>) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager.</li> <li>Consensual Process (Planned): Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase.</li> </ul>"},{"location":"core-concepts/Processes/#the-role-of-processes-in-teamwork","title":"The Role of Processes in Teamwork","text":"<p>Processes enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.</p>"},{"location":"core-concepts/Processes/#assigning-processes-to-a-crew","title":"Assigning Processes to a Crew","text":"<p>To assign a process to a crew, specify the process type upon crew creation to set the execution strategy. For a hierarchical process, ensure to define <code>manager_llm</code> or <code>manager_agent</code> for the manager agent.</p> <p><pre><code>from crewai import Crew\nfrom crewai.process import Process\nfrom langchain_openai import ChatOpenAI\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm or manager_agent\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=ChatOpenAI(model=\"gpt-4\")\n    # or\n    # manager_agent=my_manager_agent\n)\n</code></pre> Note: Ensure <code>my_agents</code> and <code>my_tasks</code> are defined prior to creating a <code>Crew</code> object, and for the hierarchical process, either <code>manager_llm</code> or <code>manager_agent</code> is also required.</p>"},{"location":"core-concepts/Processes/#sequential-process","title":"Sequential Process","text":"<p>This method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next.</p> <p>To customize task context, utilize the <code>context</code> parameter in the <code>Task</code> class to specify outputs that should be used as context for subsequent tasks.</p>"},{"location":"core-concepts/Processes/#hierarchical-process","title":"Hierarchical Process","text":"<p>Emulates a corporate hierarchy, CrewAI allows specifying a custom manager agent or automatically creates one, requiring the specification of a manager language model (<code>manager_llm</code>). This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.</p>"},{"location":"core-concepts/Processes/#process-class-detailed-overview","title":"Process Class: Detailed Overview","text":"<p>The <code>Process</code> class is implemented as an enumeration (<code>Enum</code>), ensuring type safety and restricting process values to the defined types (<code>sequential</code>, <code>hierarchical</code>). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.</p>"},{"location":"core-concepts/Processes/#conclusion","title":"Conclusion","text":"<p>The structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents. This documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.</p>"},{"location":"core-concepts/Tasks/","title":"crewAI Tasks","text":""},{"location":"core-concepts/Tasks/#overview-of-a-task","title":"Overview of a Task","text":"<p>What is a Task?</p> <p>In the crewAI framework, tasks are specific assignments completed by agents. They provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities.</p> <p>Tasks within crewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.</p>"},{"location":"core-concepts/Tasks/#task-attributes","title":"Task Attributes","text":"Attribute Parameters Type Description Description <code>description</code> <code>str</code> A clear, concise statement of what the task entails. Agent <code>agent</code> <code>Optional[BaseAgent]</code> The agent responsible for the task, assigned either directly or by the crew's process. Expected Output <code>expected_output</code> <code>str</code> A detailed description of what the task's completion looks like. Tools (optional) <code>tools</code> <code>Optional[List[Any]]</code> The functions or capabilities the agent can utilize to perform the task. Defaults to an empty list. Async Execution (optional) <code>async_execution</code> <code>Optional[bool]</code> If set, the task executes asynchronously, allowing progression without waiting for completion. Defaults to False. Context (optional) <code>context</code> <code>Optional[List[\"Task\"]]</code> Specifies tasks whose outputs are used as context for this task. Config (optional) <code>config</code> <code>Optional[Dict[str, Any]]</code> Additional configuration details for the agent executing the task, allowing further customization. Defaults to None. Output JSON (optional) <code>output_json</code> <code>Optional[Type[BaseModel]]</code> Outputs a JSON object, requiring an OpenAI client. Only one output format can be set. Output Pydantic (optional) <code>output_pydantic</code> <code>Optional[Type[BaseModel]]</code> Outputs a Pydantic model object, requiring an OpenAI client. Only one output format can be set. Output File (optional) <code>output_file</code> <code>Optional[str]</code> Saves the task output to a file. If used with <code>Output JSON</code> or <code>Output Pydantic</code>, specifies how the output is saved. Output (optional) <code>output</code> <code>Optional[TaskOutput]</code> An instance of <code>TaskOutput</code>, containing the raw, JSON, and Pydantic output plus additional details. Callback (optional) <code>callback</code> <code>Optional[Any]</code> A callable that is executed with the task's output upon completion. Human Input (optional) <code>human_input</code> <code>Optional[bool]</code> Indicates if the task should involve human review at the end, useful for tasks needing human oversight. Defaults to False. Converter Class (optional) <code>converter_cls</code> <code>Optional[Type[Converter]]</code> A converter class used to export structured output. Defaults to None."},{"location":"core-concepts/Tasks/#creating-a-task","title":"Creating a Task","text":"<p>Creating a task involves defining its scope, responsible agent, and any additional attributes for flexibility:</p> <pre><code>from crewai import Task\n\ntask = Task(\n    description='Find and summarize the latest and most relevant news on AI',\n    agent=sales_agent,\n    expected_output='A bullet list summary of the top 5 most important AI news',\n)\n</code></pre> <p>Task Assignment</p> <p>Directly specify an <code>agent</code> for assignment or let the <code>hierarchical</code> CrewAI's process decide based on roles, availability, etc.</p>"},{"location":"core-concepts/Tasks/#task-output","title":"Task Output","text":"<p>Understanding Task Outputs</p> <p>The output of a task in the crewAI framework is encapsulated within the <code>TaskOutput</code> class. This class provides a structured way to access results of a task, including various formats such as raw output, JSON, and Pydantic models. By default, the <code>TaskOutput</code> will only include the <code>raw</code> output. A <code>TaskOutput</code> will only include the <code>pydantic</code> or <code>json_dict</code> output if the original <code>Task</code> object was configured with <code>output_pydantic</code> or <code>output_json</code>, respectively.</p>"},{"location":"core-concepts/Tasks/#task-output-attributes","title":"Task Output Attributes","text":"Attribute Parameters Type Description Description <code>description</code> <code>str</code> Description of the task. Summary <code>summary</code> <code>Optional[str]</code> Summary of the task, auto-generated from the first 10 words of the description. Raw <code>raw</code> <code>str</code> The raw output of the task. This is the default format for the output. Pydantic <code>pydantic</code> <code>Optional[BaseModel]</code> A Pydantic model object representing the structured output of the task. JSON Dict <code>json_dict</code> <code>Optional[Dict[str, Any]]</code> A dictionary representing the JSON output of the task. Agent <code>agent</code> <code>str</code> The agent that executed the task. Output Format <code>output_format</code> <code>OutputFormat</code> The format of the task output, with options including RAW, JSON, and Pydantic. The default is RAW."},{"location":"core-concepts/Tasks/#task-methods-and-properties","title":"Task Methods and Properties","text":"Method/Property Description json Returns the JSON string representation of the task output if the output format is JSON. to_dict Converts the JSON and Pydantic outputs to a dictionary. str Returns the string representation of the task output, prioritizing Pydantic, then JSON, then raw."},{"location":"core-concepts/Tasks/#accessing-task-outputs","title":"Accessing Task Outputs","text":"<p>Once a task has been executed, its output can be accessed through the <code>output</code> attribute of the <code>Task</code> object. The <code>TaskOutput</code> class provides various ways to interact with and present this output.</p>"},{"location":"core-concepts/Tasks/#example","title":"Example","text":"<pre><code># Example task\ntask = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n# Execute the crew\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Accessing the task output\ntask_output = task.output\n\nprint(f\"Task Description: {task_output.description}\")\nprint(f\"Task Summary: {task_output.summary}\")\nprint(f\"Raw Output: {task_output.raw}\")\nif task_output.json_dict:\n    print(f\"JSON Output: {json.dumps(task_output.json_dict, indent=2)}\")\nif task_output.pydantic:\n    print(f\"Pydantic Output: {task_output.pydantic}\")\n</code></pre>"},{"location":"core-concepts/Tasks/#integrating-tools-with-tasks","title":"Integrating Tools with Tasks","text":"<p>Leverage tools from the crewAI Toolkit and LangChain Tools for enhanced task performance and agent interaction.</p>"},{"location":"core-concepts/Tasks/#creating-a-task-with-tools","title":"Creating a Task with Tools","text":"<pre><code>import os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\n# to perform a semantic search for a specified query from a text's content across the internet\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=True\n)\n\nresult = crew.kickoff()\nprint(result)\n</code></pre> <p>This demonstrates how tasks with specific tools can override an agent's default set for tailored task execution.</p>"},{"location":"core-concepts/Tasks/#referring-to-other-tasks","title":"Referring to Other Tasks","text":"<p>In crewAI, the output of one task is automatically relayed into the next one, but you can specifically define what tasks' output, including multiple, should be used as context for another task.</p> <p>This is useful when you have a task that depends on the output of another task that is not performed immediately after it. This is done through the <code>context</code> attribute of the task:</p> <pre><code># ...\n\nresearch_ai_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description='Find and summarize the latest AI Ops news',\n    expected_output='A bullet list summary of the top 5 most important AI Ops news',\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output='Full blog post that is 4 paragraphs long',\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>You can define a task to be executed asynchronously. This means that the crew will not wait for it to be completed to continue with the next task. This is useful for tasks that take a long time to be completed, or that are not crucial for the next tasks to be performed.</p> <p>You can then use the <code>context</code> attribute to define in a future task that it should wait for the output of the asynchronous task to be completed.</p> <pre><code>#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#callback-mechanism","title":"Callback Mechanism","text":"<p>The callback function is executed after the task is completed, allowing for actions or notifications to be triggered based on the task's outcome.</p> <pre><code># ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#accessing-a-specific-task-output","title":"Accessing a Specific Task Output","text":"<p>Once a crew finishes running, you can access the output of a specific task by using the <code>output</code> attribute of the task object:</p> <pre><code># ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=True\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw}\n\"\"\")\n</code></pre>"},{"location":"core-concepts/Tasks/#tool-override-mechanism","title":"Tool Override Mechanism","text":"<p>Specifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility.</p>"},{"location":"core-concepts/Tasks/#error-handling-and-validation-mechanisms","title":"Error Handling and Validation Mechanisms","text":"<p>While creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to:</p> <ul> <li>Ensuring only one output type is set per task to maintain clear output expectations.</li> <li>Preventing the manual assignment of the <code>id</code> attribute to uphold the integrity of the unique identifier system.</li> </ul> <p>These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.</p>"},{"location":"core-concepts/Tasks/#creating-directories-when-saving-files","title":"Creating Directories when Saving Files","text":"<p>You can now specify if a task should create directories when saving its output to a file. This is particularly useful for organizing outputs and ensuring that file paths are correctly structured.</p> <pre><code># ...\n\nsave_output_task = Task(\n    description='Save the summarized AI news to a file',\n    expected_output='File saved successfully',\n    agent=research_agent,\n    tools=[file_save_tool],\n    output_file='outputs/ai_news_summary.txt',\n    create_directory=True\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#conclusion","title":"Conclusion","text":"<p>Tasks are the driving force behind the actions of agents in crewAI. By properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit. Equipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential, ensuring agents are effectively prepared for their assignments and that tasks are executed as intended.</p>"},{"location":"core-concepts/Testing/","title":"crewAI Testing","text":""},{"location":"core-concepts/Testing/#introduction","title":"Introduction","text":"<p>Testing is a crucial part of the development process, and it is essential to ensure that your crew is performing as expected. With crewAI, you can easily test your crew and evaluate its performance using the built-in testing capabilities.</p>"},{"location":"core-concepts/Testing/#using-the-testing-feature","title":"Using the Testing Feature","text":"<p>We added the CLI command <code>crewai test</code> to make it easy to test your crew. This command will run your crew for a specified number of iterations and provide detailed performance metrics. The parameters are <code>n_iterations</code> and <code>model</code>, which are optional and default to 2 and <code>gpt-4o-mini</code> respectively. For now, the only provider available is OpenAI.</p> <pre><code>crewai test\n</code></pre> <p>If you want to run more iterations or use a different model, you can specify the parameters like this:</p> <pre><code>crewai test --n_iterations 5 --model gpt-4o\n</code></pre> <p>or using the short forms:</p> <pre><code>crewai test -n 5 -m gpt-4o\n</code></pre> <p>When you run the <code>crewai test</code> command, the crew will be executed for the specified number of iterations, and the performance metrics will be displayed at the end of the run.</p> <p>A table of scores at the end will show the performance of the crew in terms of the following metrics:</p> <pre><code>                                                     Tasks Scores\n                                                (1-10 Higher is better)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Tasks/Crew/Agents  \u2502 Run 1 \u2502 Run 2 \u2502 Avg. Total \u2502 Agents                         \u2502                                 \u2503\n\u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528\n\u2503 Task 1             \u2502  9.0  \u2502  9.5  \u2502    9.2     \u2502 - Professional Insights        \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502 Researcher                     \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502                                \u2502                                 \u2503\n\u2503 Task 2             \u2502  9.0  \u2502 10.0  \u2502    9.5     \u2502 - Company Profile Investigator \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502                                \u2502                                 \u2503\n\u2503 Task 3             \u2502  9.0  \u2502  9.0  \u2502    9.0     \u2502 - Automation Insights          \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502 Specialist                     \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502                                \u2502                                 \u2503\n\u2503 Task 4             \u2502  9.0  \u2502  9.0  \u2502    9.0     \u2502 - Final Report Compiler        \u2502                                 \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502                                \u2502 - Automation Insights           \u2503\n\u2503                    \u2502       \u2502       \u2502            \u2502                                \u2502 Specialist                      \u2503\n\u2503 Crew               \u2502 9.00  \u2502 9.38  \u2502    9.2     \u2502                                \u2502                                 \u2503\n\u2503 Execution Time (s) \u2502  126  \u2502  145  \u2502    135     \u2502                                \u2502                                 \u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n</code></pre> <p>The example above shows the test results for two runs of the crew with two tasks, with the average total score for each task and the crew as a whole.</p>"},{"location":"core-concepts/Tools/","title":"crewAI Tools","text":""},{"location":"core-concepts/Tools/#introduction","title":"Introduction","text":"<p>CrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers. This documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.</p>"},{"location":"core-concepts/Tools/#what-is-a-tool","title":"What is a Tool?","text":"<p>Definition</p> <p>A tool in CrewAI is a skill or function that agents can utilize to perform various actions. This includes tools from the crewAI Toolkit and LangChain Tools, enabling everything from simple searches to complex interactions and effective teamwork among agents.</p>"},{"location":"core-concepts/Tools/#key-characteristics-of-tools","title":"Key Characteristics of Tools","text":"<ul> <li>Utility: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration.</li> <li>Integration: Boosts agent capabilities by seamlessly integrating tools into their workflow.</li> <li>Customizability: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents.</li> <li>Error Handling: Incorporates robust error handling mechanisms to ensure smooth operation.</li> <li>Caching Mechanism: Features intelligent caching to optimize performance and reduce redundant operations.</li> </ul>"},{"location":"core-concepts/Tools/#using-crewai-tools","title":"Using crewAI Tools","text":"<p>To enhance your agents' capabilities with crewAI tools, begin by installing our extra tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>Here's an example demonstrating their use:</p> <pre><code>import os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew with planning enabled\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=True,\n    planning=True,  # Enable planning feature\n)\n\n# Execute tasks\ncrew.kickoff()\n</code></pre>"},{"location":"core-concepts/Tools/#available-crewai-tools","title":"Available crewAI Tools","text":"<ul> <li>Error Handling: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks.</li> <li>Caching Mechanism: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time. You can also define finer control over the caching mechanism using the <code>cache_function</code> attribute on the tool.</li> </ul> <p>Here is a list of the available tools and their descriptions:</p> Tool Description BrowserbaseLoadTool A tool for interacting with and extracting data from web browsers. CodeDocsSearchTool A RAG tool optimized for searching through code documentation and related technical documents. CodeInterpreterTool A tool for interpreting python code. ComposioTool Enables use of Composio tools. CSVSearchTool A RAG tool designed for searching within CSV files, tailored to handle structured data. DALL-E Tool A tool for generating images using the DALL-E API. DirectorySearchTool A RAG tool for searching within directories, useful for navigating through file systems. DOCXSearchTool A RAG tool aimed at searching within DOCX documents, ideal for processing Word files. DirectoryReadTool Facilitates reading and processing of directory structures and their contents. EXASearchTool A tool designed for performing exhaustive searches across various data sources. FileReadTool Enables reading and extracting data from files, supporting various file formats. FirecrawlSearchTool A tool to search webpages using Firecrawl and return the results. FirecrawlCrawlWebsiteTool A tool for crawling webpages using Firecrawl. FirecrawlScrapeWebsiteTool A tool for scraping webpages URL using Firecrawl and returning its contents. GithubSearchTool A RAG tool for searching within GitHub repositories, useful for code and documentation search. SerperDevTool A specialized tool for development purposes, with specific functionalities under development. TXTSearchTool A RAG tool focused on searching within text (.txt) files, suitable for unstructured data. JSONSearchTool A RAG tool designed for searching within JSON files, catering to structured data handling. LlamaIndexTool Enables the use of LlamaIndex tools. MDXSearchTool A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation. PDFSearchTool A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents. PGSearchTool A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. Vision Tool A tool for generating images using the DALL-E API. RagTool A general-purpose RAG tool capable of handling various data sources and types. ScrapeElementFromWebsiteTool Enables scraping specific elements from websites, useful for targeted data extraction. ScrapeWebsiteTool Facilitates scraping entire websites, ideal for comprehensive data collection. WebsiteSearchTool A RAG tool for searching website content, optimized for web data extraction. XMLSearchTool A RAG tool designed for searching within XML files, suitable for structured data formats. YoutubeChannelSearchTool A RAG tool for searching within YouTube channels, useful for video content analysis. YoutubeVideoSearchTool A RAG tool aimed at searching within YouTube videos, ideal for video data extraction."},{"location":"core-concepts/Tools/#creating-your-own-tools","title":"Creating your own Tools","text":"<p>Custom Tool Creation</p> <p>Developers can craft custom tools tailored for their agent\u2019s needs or utilize pre-built options:</p> <p>To create your own crewAI tools you will need to install our extra tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>Once you do that there are two main ways for one to create a crewAI tool:</p>"},{"location":"core-concepts/Tools/#subclassing-basetool","title":"Subclassing <code>BaseTool</code>","text":"<pre><code>from crewai_tools import BaseTool\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"Clear description for what this tool is useful for, your agent will need this information to use it.\"\n\n    def _run(self, argument: str) -&gt; str:\n        # Implementation goes here\n        return \"Result from custom tool\"\n</code></pre>"},{"location":"core-concepts/Tools/#utilizing-the-tool-decorator","title":"Utilizing the <code>tool</code> Decorator","text":"<pre><code>from crewai_tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -&gt; str:\n    \"\"\"Clear description for what this tool is useful for, your agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"\n</code></pre>"},{"location":"core-concepts/Tools/#custom-caching-mechanism","title":"Custom Caching Mechanism","text":"<p>Caching</p> <p>Tools can optionally implement a <code>cache_function</code> to fine-tune caching behavior. This function determines when to cache results based on specific conditions, offering granular control over caching logic.</p> <pre><code>from crewai_tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -&gt; str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lessons of math for kids.\",\n        backstory=\"You're an expert in writing and you love to teach kids but you know nothing of math.\",\n        tools=[multiplication_tool],\n        allow_delegation=False,\n    )\n    #...\n</code></pre>"},{"location":"core-concepts/Tools/#conclusion","title":"Conclusion","text":"<p>Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively. When building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.</p>"},{"location":"core-concepts/Training-Crew/","title":"crewAI Train","text":""},{"location":"core-concepts/Training-Crew/#introduction","title":"Introduction","text":"<p>The training feature in CrewAI allows you to train your AI agents using the command-line interface (CLI). By running the command <code>crewai train -n &lt;n_iterations&gt;</code>, you can specify the number of iterations for the training process.</p> <p>During training, CrewAI utilizes techniques to optimize the performance of your agents along with human feedback. This helps the agents improve their understanding, decision-making, and problem-solving abilities.</p>"},{"location":"core-concepts/Training-Crew/#training-your-crew-using-the-cli","title":"Training Your Crew Using the CLI","text":"<p>To use the training feature, follow these steps:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Navigate to the directory where your CrewAI project is located.</li> <li>Run the following command:</li> </ol> <pre><code>crewai train -n &lt;n_iterations&gt; &lt;filename&gt; (optional)\n</code></pre> <p>Replace <code>&lt;n_iterations&gt;</code> with the desired number of training iterations and <code>&lt;filename&gt;</code> with the appropriate filename ending with <code>.pkl</code>.</p>"},{"location":"core-concepts/Training-Crew/#training-your-crew-programmatically","title":"Training Your Crew Programmatically","text":"<p>To train your crew programmatically, use the following steps:</p> <ol> <li>Define the number of iterations for training.</li> <li>Specify the input parameters for the training process.</li> <li>Execute the training command within a try-except block to handle potential errors.</li> </ol> <pre><code>n_iterations = 2\ninputs = {\"topic\": \"CrewAI Training\"}\nfilename = \"your_model.pkl\"\n\ntry:\n    YourCrewName_Crew().crew().train(n_iterations=n_iterations, inputs=inputs, filename=filename)\n\nexcept Exception as e:\n    raise Exception(f\"An error occurred while training the crew: {e}\")\n</code></pre>"},{"location":"core-concepts/Training-Crew/#key-points-to-note","title":"Key Points to Note:","text":"<ul> <li>Positive Integer Requirement: Ensure that the number of iterations (<code>n_iterations</code>) is a positive integer. The code will raise a <code>ValueError</code> if this condition is not met.</li> <li>Filename Requirement: Ensure that the filename ends with <code>.pkl</code>. The code will raise a <code>ValueError</code> if this condition is not met.</li> <li>Error Handling: The code handles subprocess errors and unexpected exceptions, providing error messages to the user.</li> </ul> <p>It is important to note that the training process may take some time, depending on the complexity of your agents and will also require your feedback on each iteration.</p> <p>Once the training is complete, your agents will be equipped with enhanced capabilities and knowledge, ready to tackle complex tasks and provide more consistent and valuable insights.</p> <p>Remember to regularly update and retrain your agents to ensure they stay up-to-date with the latest information and advancements in the field.</p> <p>Happy training with CrewAI!</p>"},{"location":"core-concepts/Using-LangChain-Tools/","title":"Using LangChain Tools","text":""},{"location":"core-concepts/Using-LangChain-Tools/#using-langchain-tools","title":"Using LangChain Tools","text":"<p>LangChain Integration</p> <p>CrewAI seamlessly integrates with LangChain\u2019s comprehensive list of tools, all of which can be used with crewAI.</p> <pre><code>import os\nfrom crewai import Agent\nfrom langchain.agents import Tool\nfrom langchain.utilities import GoogleSerperAPIWrapper\n\n# Setup API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\nsearch = GoogleSerperAPIWrapper()\n\n# Create and assign the search tool to an agent\nserper_tool = Tool(\n  name=\"Intermediate Answer\",\n  func=search.run,\n  description=\"Useful for search-based queries\",\n)\n\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[serper_tool]\n)\n\n# rest of the code ...\n</code></pre>"},{"location":"core-concepts/Using-LangChain-Tools/#conclusion","title":"Conclusion","text":"<p>Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively. When building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.</p>"},{"location":"core-concepts/Using-LlamaIndex-Tools/","title":"Using LlamaIndex Tools","text":""},{"location":"core-concepts/Using-LlamaIndex-Tools/#using-llamaindex-tools","title":"Using LlamaIndex Tools","text":"<p>LlamaIndex Integration</p> <p>CrewAI seamlessly integrates with LlamaIndex\u2019s comprehensive toolkit for RAG (Retrieval-Augmented Generation) and agentic pipelines, enabling advanced search-based queries and more. Here are the available built-in tools offered by LlamaIndex.</p> <pre><code>from crewai import Agent\nfrom crewai_tools import LlamaIndexTool\n\n# Example 1: Initialize from FunctionTool\nfrom llama_index.core.tools import FunctionTool\n\nyour_python_function = lambda ...: ...\nog_tool = FunctionTool.from_defaults(your_python_function, name=\"&lt;name&gt;\", description='&lt;description&gt;')\ntool = LlamaIndexTool.from_tool(og_tool)\n\n# Example 2: Initialize from LlamaHub Tools\nfrom llama_index.tools.wolfram_alpha import WolframAlphaToolSpec\nwolfram_spec = WolframAlphaToolSpec(app_id=\"&lt;app_id&gt;\")\nwolfram_tools = wolfram_spec.to_tool_list()\ntools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]\n\n# Example 3: Initialize Tool from a LlamaIndex Query Engine\nquery_engine = index.as_query_engine()\nquery_tool = LlamaIndexTool.from_query_engine(\n    query_engine,\n    name=\"Uber 2019 10K Query Tool\",\n    description=\"Use this tool to lookup the 2019 Uber 10K Annual Report\"\n)\n\n# Create and assign the tools to an agent\nagent = Agent(\n    role='Research Analyst',\n    goal='Provide up-to-date market analysis',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[tool, *tools, query_tool]\n)\n\n# rest of the code ...\n</code></pre>"},{"location":"core-concepts/Using-LlamaIndex-Tools/#steps-to-get-started","title":"Steps to Get Started","text":"<p>To effectively use the LlamaIndexTool, follow these steps:</p> <ol> <li> <p>Package Installation: Confirm that the <code>crewai[tools]</code> package is installed in your Python environment.</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> </li> <li> <p>Install and Use LlamaIndex: Follow the LlamaIndex documentation LlamaIndex Documentation to set up a RAG/agent pipeline.</p> </li> </ol>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/","title":"Creating a CrewAI Pipeline Project","text":"<p>Welcome to the comprehensive guide for creating a new CrewAI pipeline project. This document will walk you through the steps to create, customize, and run your CrewAI pipeline project, ensuring you have everything you need to get started.</p> <p>To learn more about CrewAI pipelines, visit the CrewAI documentation.</p>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#prerequisites","title":"Prerequisites","text":"<p>Before getting started with CrewAI pipelines, make sure that you have installed CrewAI via pip:</p> <pre><code>$ pip install crewai crewai-tools\n</code></pre> <p>The same prerequisites for virtual environments and Code IDEs apply as in regular CrewAI projects.</p>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#creating-a-new-pipeline-project","title":"Creating a New Pipeline Project","text":"<p>To create a new CrewAI pipeline project, you have two options:</p> <ol> <li>For a basic pipeline template:</li> </ol> <pre><code>$ crewai create pipeline &lt;project_name&gt;\n</code></pre> <ol> <li>For a pipeline example that includes a router:</li> </ol> <pre><code>$ crewai create pipeline --router &lt;project_name&gt;\n</code></pre> <p>These commands will create a new project folder with the following structure:</p> <pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 &lt;project_name&gt;/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 main.py\n\u2502       \u251c\u2500\u2500 crews/\n\u2502       \u2502   \u251c\u2500\u2500 crew1/\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 crew1.py\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 config/\n\u2502       \u2502   \u2502       \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2502       \u2514\u2500\u2500 tasks.yaml\n\u2502       \u2502   \u251c\u2500\u2500 crew2/\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 crew2.py\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 config/\n\u2502       \u2502   \u2502       \u251c\u2500\u2500 agents.yaml\n\u2502       \u2502   \u2502       \u2514\u2500\u2500 tasks.yaml\n\u2502       \u251c\u2500\u2500 pipelines/\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u251c\u2500\u2500 pipeline1.py\n\u2502       \u2502   \u2514\u2500\u2500 pipeline2.py\n\u2502       \u2514\u2500\u2500 tools/\n\u2502           \u251c\u2500\u2500 __init__.py\n\u2502           \u2514\u2500\u2500 custom_tool.py\n\u2514\u2500\u2500 tests/\n</code></pre>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#customizing-your-pipeline-project","title":"Customizing Your Pipeline Project","text":"<p>To customize your pipeline project, you can:</p> <ol> <li>Modify the crew files in <code>src/&lt;project_name&gt;/crews/</code> to define your agents and tasks for each crew.</li> <li>Modify the pipeline files in <code>src/&lt;project_name&gt;/pipelines/</code> to define your pipeline structure.</li> <li>Modify <code>src/&lt;project_name&gt;/main.py</code> to set up and run your pipelines.</li> <li>Add your environment variables into the <code>.env</code> file.</li> </ol>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#example-1-defining-a-two-stage-sequential-pipeline","title":"Example 1: Defining a Two-Stage Sequential Pipeline","text":"<p>Here's an example of how to define a pipeline with sequential stages in <code>src/&lt;project_name&gt;/pipelines/pipeline.py</code>:</p> <pre><code>from crewai import Pipeline\nfrom crewai.project import PipelineBase\nfrom ..crews.research_crew.research_crew import ResearchCrew\nfrom ..crews.write_x_crew.write_x_crew import WriteXCrew\n\n@PipelineBase\nclass SequentialPipeline:\n    def __init__(self):\n        # Initialize crews\n        self.research_crew = ResearchCrew().crew()\n        self.write_x_crew = WriteXCrew().crew()\n\n    def create_pipeline(self):\n        return Pipeline(\n            stages=[\n                self.research_crew,\n                self.write_x_crew\n            ]\n        )\n\n    async def kickoff(self, inputs):\n        pipeline = self.create_pipeline()\n        results = await pipeline.kickoff(inputs)\n        return results\n</code></pre>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#example-2-defining-a-two-stage-pipeline-with-parallel-execution","title":"Example 2: Defining a Two-Stage Pipeline with Parallel Execution","text":"<pre><code>from crewai import Pipeline\nfrom crewai.project import PipelineBase\nfrom ..crews.research_crew.research_crew import ResearchCrew\nfrom ..crews.write_x_crew.write_x_crew import WriteXCrew\nfrom ..crews.write_linkedin_crew.write_linkedin_crew import WriteLinkedInCrew\n\n@PipelineBase\nclass ParallelExecutionPipeline:\n    def __init__(self):\n        # Initialize crews\n        self.research_crew = ResearchCrew().crew()\n        self.write_x_crew = WriteXCrew().crew()\n        self.write_linkedin_crew = WriteLinkedInCrew().crew()\n\n    def create_pipeline(self):\n        return Pipeline(\n            stages=[\n                self.research_crew,\n                [self.write_x_crew, self.write_linkedin_crew]  # Parallel execution\n            ]\n        )\n\n    async def kickoff(self, inputs):\n        pipeline = self.create_pipeline()\n        results = await pipeline.kickoff(inputs)\n        return results\n</code></pre>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#annotations","title":"Annotations","text":"<p>The main annotation you'll use for pipelines is <code>@PipelineBase</code>. This annotation is used to decorate your pipeline classes, similar to how <code>@CrewBase</code> is used for crews.</p>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#installing-dependencies","title":"Installing Dependencies","text":"<p>To install the dependencies for your project, use Poetry:</p> <pre><code>$ cd &lt;project_name&gt;\n$ crewai install\n</code></pre>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#running-your-pipeline-project","title":"Running Your Pipeline Project","text":"<p>To run your pipeline project, use the following command:</p> <pre><code>$ crewai run\n</code></pre> <p>This will initialize your pipeline and begin task execution as defined in your <code>main.py</code> file.</p>"},{"location":"getting-started/Create-a-New-CrewAI-Pipeline-Template-Method/#deploying-your-pipeline-project","title":"Deploying Your Pipeline Project","text":"<p>Pipelines can be deployed in the same way as regular CrewAI projects. The easiest way is through CrewAI+, where you can deploy your pipeline in a few clicks.</p> <p>Remember, when working with pipelines, you're orchestrating multiple crews to work together in a sequence or parallel fashion. This allows for more complex workflows and information processing tasks.</p>"},{"location":"getting-started/Installing-CrewAI/","title":"Installing crewAI","text":"<p>Welcome to crewAI! This guide will walk you through the installation process for crewAI and its dependencies. crewAI is a flexible and powerful AI framework that enables you to create and manage AI agents, tools, and tasks efficiently. Let's get started!</p>"},{"location":"getting-started/Installing-CrewAI/#installation","title":"Installation","text":"<p>To install crewAI, you need to have Python &gt;=3.10 and &lt;=3.13 installed on your system:</p> <pre><code># Install the main crewAI package\npip install crewai\n\n# Install the main crewAI package and the tools package\n# that includes a series of helpful tools for your agents\npip install 'crewai[tools]'\n\n# Alternatively, you can also use:\npip install crewai crewai-tools\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/","title":"Starting Your CrewAI Project","text":"<p>Welcome to the ultimate guide for starting a new CrewAI project. This document will walk you through the steps to create, customize, and run your CrewAI project, ensuring you have everything you need to get started.</p> <p>Before we start, there are a couple of things to note:</p> <ol> <li>CrewAI is a Python package and requires Python &gt;=3.10 and &lt;=3.13 to run.</li> <li>The preferred way of setting up CrewAI is using the <code>crewai create crew</code> command. This will create a new project folder and install a skeleton template for you to work on.</li> </ol>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#prerequisites","title":"Prerequisites","text":"<p>Before getting started with CrewAI, make sure that you have installed it via pip:</p> <pre><code>$ pip install 'crewai[tools]'\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#creating-a-new-project","title":"Creating a New Project","text":"<p>In this example, we will be using poetry as our virtual environment manager.</p> <p>To create a new CrewAI project, run the following CLI command:</p> <pre><code>$ crewai create crew &lt;project_name&gt;\n</code></pre> <p>This command will create a new project folder with the following structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 my_project/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 crew.py\n        \u251c\u2500\u2500 tools/\n        \u2502   \u251c\u2500\u2500 custom_tool.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 config/\n            \u251c\u2500\u2500 agents.yaml\n            \u2514\u2500\u2500 tasks.yaml\n</code></pre> <p>You can now start developing your project by editing the files in the <code>src/my_project</code> folder. The <code>main.py</code> file is the entry point of your project, and the <code>crew.py</code> file is where you define your agents and tasks.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#customizing-your-project","title":"Customizing Your Project","text":"<p>To customize your project, you can: - Modify <code>src/my_project/config/agents.yaml</code> to define your agents. - Modify <code>src/my_project/config/tasks.yaml</code> to define your tasks. - Modify <code>src/my_project/crew.py</code> to add your own logic, tools, and specific arguments. - Modify <code>src/my_project/main.py</code> to add custom inputs for your agents and tasks. - Add your environment variables into the <code>.env</code> file.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#example-defining-agents-and-tasks","title":"Example: Defining Agents and Tasks","text":""},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#agentsyaml","title":"agents.yaml","text":"<pre><code>researcher:\n  role: &gt;\n    Job Candidate Researcher\n  goal: &gt;\n    Find potential candidates for the job\n  backstory: &gt;\n    You are adept at finding the right candidates by exploring various online\n    resources. Your skill in identifying suitable candidates ensures the best\n    match for job positions.\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#tasksyaml","title":"tasks.yaml","text":"<pre><code>research_candidates_task:\n  description: &gt;\n    Conduct thorough research to find potential candidates for the specified job.\n    Utilize various online resources and databases to gather a comprehensive list of potential candidates.\n    Ensure that the candidates meet the job requirements provided.\n\n    Job Requirements:\n    {job_requirements}\n  expected_output: &gt;\n    A list of 10 potential candidates with their contact information and brief profiles highlighting their suitability.\n  agent: researcher # THIS NEEDS TO MATCH THE AGENT NAME IN THE AGENTS.YAML FILE AND THE AGENT DEFINED IN THE crew.py FILE\n  context: # THESE NEED TO MATCH THE TASK NAMES DEFINED ABOVE AND THE TASKS.YAML FILE AND THE TASK DEFINED IN THE crew.py FILE\n    - researcher\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#referencing-variables","title":"Referencing Variables:","text":"<p>Your defined functions with the same name will be used. For example, you can reference the agent for specific tasks from <code>tasks.yaml</code> file. Ensure your annotated agent and function name are the same; otherwise, your task won't recognize the reference properly.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#example-references","title":"Example References","text":"<p><code>agents.yaml</code></p> <pre><code>email_summarizer:\n    role: &gt;\n      Email Summarizer\n    goal: &gt;\n      Summarize emails into a concise and clear summary\n    backstory: &gt;\n      You will create a 5 bullet point summary of the report\n    llm: mixtal_llm\n</code></pre> <p><code>tasks.yaml</code></p> <pre><code>email_summarizer_task:\n    description: &gt;\n      Summarize the email into a 5 bullet point summary\n    expected_output: &gt;\n      A 5 bullet point summary of the email\n    agent: email_summarizer\n    context:\n      - reporting_task\n      - research_task\n</code></pre> <p>Use the annotations to properly reference the agent and task in the <code>crew.py</code> file.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#annotations-include","title":"Annotations include:","text":"<ul> <li><code>@agent</code></li> <li><code>@task</code></li> <li><code>@crew</code></li> <li><code>@tool</code></li> <li><code>@callback</code></li> <li><code>@output_json</code></li> <li><code>@output_pydantic</code></li> <li><code>@cache_handler</code></li> </ul> <p><code>crew.py</code></p> <pre><code># ...\n@agent\ndef email_summarizer(self) -&gt; Agent:\n    return Agent(\n        config=self.agents_config[\"email_summarizer\"],\n    )\n\n@task\ndef email_summarizer_task(self) -&gt; Task:\n    return Task(\n        config=self.tasks_config[\"email_summarizer_task\"],\n    )\n# ...\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#installing-dependencies","title":"Installing Dependencies","text":"<p>To install the dependencies for your project, you can use Poetry. First, navigate to your project directory:</p> <pre><code>$ cd my_project\n$ crewai install\n</code></pre> <p>This will install the dependencies specified in the <code>pyproject.toml</code> file.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#interpolating-variables","title":"Interpolating Variables","text":"<p>Any variable interpolated in your <code>agents.yaml</code> and <code>tasks.yaml</code> files like <code>{variable}</code> will be replaced by the value of the variable in the <code>main.py</code> file.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#tasksyaml_1","title":"tasks.yaml","text":"<pre><code>research_task:\n  description: &gt;\n    Conduct a thorough research about the customer and competitors in the context\n    of {customer_domain}.\n    Make sure you find any interesting and relevant information given the\n    current year is 2024.\n  expected_output: &gt;\n    A complete report on the customer and their customers and competitors,\n    including their demographics, preferences, market positioning and audience engagement.\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#mainpy","title":"main.py","text":"<pre><code># main.py\ndef run():\n    inputs = {\n        \"customer_domain\": \"crewai.com\"\n    }\n    MyProjectCrew(inputs).crew().kickoff(inputs=inputs)\n</code></pre>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#running-your-project","title":"Running Your Project","text":"<p>To run your project, use the following command:</p> <pre><code>$ crewai run\n</code></pre> <p>This will initialize your crew of AI agents and begin task execution as defined in your configuration in the <code>main.py</code> file.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#replay-tasks-from-latest-crew-kickoff","title":"Replay Tasks from Latest Crew Kickoff","text":"<p>CrewAI now includes a replay feature that allows you to list the tasks from the last run and replay from a specific one. To use this feature, run:</p> <pre><code>$ crewai replay &lt;task_id&gt;\n</code></pre> <p>Replace <code>&lt;task_id&gt;</code> with the ID of the task you want to replay.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#reset-crew-memory","title":"Reset Crew Memory","text":"<p>If you need to reset the memory of your crew before running it again, you can do so by calling the reset memory feature:</p> <pre><code>$ crewai reset-memory\n</code></pre> <p>This will clear the crew's memory, allowing for a fresh start.</p>"},{"location":"getting-started/Start-a-New-CrewAI-Project-Template-Method/#deploying-your-project","title":"Deploying Your Project","text":"<p>The easiest way to deploy your crew is through CrewAI+, where you can deploy your crew in a few clicks.</p>"},{"location":"how-to/AgentOps-Observability/","title":"Intro","text":"<p>Observability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing, how their agents are interacting with users, and how their agents use external tools and APIs. AgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents.</p>"},{"location":"how-to/AgentOps-Observability/#agentops","title":"AgentOps","text":"<p>AgentOps provides session replays, metrics, and monitoring for agents.</p> <p>At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more. For more info, check out the AgentOps Repo.</p>"},{"location":"how-to/AgentOps-Observability/#overview","title":"Overview","text":"<p>AgentOps provides monitoring for agents in development and production. It provides a dashboard for tracking agent performance, session replays, and custom reporting.</p> <p>Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time. This feature is useful for debugging and understanding how agents interact with users as well as other agents.</p> <p> </p>"},{"location":"how-to/AgentOps-Observability/#features","title":"Features","text":"<ul> <li>LLM Cost Management and Tracking: Track spend with foundation model providers.</li> <li>Replay Analytics: Watch step-by-step agent execution graphs.</li> <li>Recursive Thought Detection: Identify when agents fall into infinite loops.</li> <li>Custom Reporting: Create custom analytics on agent performance.</li> <li>Analytics Dashboard: Monitor high-level statistics about agents in development and production.</li> <li>Public Model Testing: Test your agents against benchmarks and leaderboards.</li> <li>Custom Tests: Run your agents against domain-specific tests.</li> <li>Time Travel Debugging: Restart your sessions from checkpoints.</li> <li>Compliance and Security: Create audit logs and detect potential threats such as profanity and PII leaks.</li> <li>Prompt Injection Detection: Identify potential code injection and secret leaks.</li> </ul>"},{"location":"how-to/AgentOps-Observability/#using-agentops","title":"Using AgentOps","text":"<ol> <li> <p>Create an API Key:    Create a user API key here: Create API Key</p> </li> <li> <p>Configure Your Environment:    Add your API key to your environment variables</p> </li> </ol> <pre><code>AGENTOPS_API_KEY=&lt;YOUR_AGENTOPS_API_KEY&gt;\n</code></pre> <ol> <li>Install AgentOps:    Install AgentOps with:    <pre><code>pip install crewai[agentops]\n</code></pre>    or    <pre><code>pip install agentops\n</code></pre></li> </ol> <p>Before using <code>Crew</code> in your script, include these lines:</p> <pre><code>import agentops\nagentops.init()\n</code></pre> <p>This will initiate an AgentOps session as well as automatically track Crew agents. For further info on how to outfit more complex agentic systems, check out the AgentOps documentation or join the Discord.</p>"},{"location":"how-to/AgentOps-Observability/#crew-agentops-examples","title":"Crew + AgentOps Examples","text":"<ul> <li>Job Posting</li> <li>Markdown Validator</li> <li>Instagram Post</li> </ul>"},{"location":"how-to/AgentOps-Observability/#further-information","title":"Further Information","text":"<p>To get started, create an AgentOps account.</p> <p>For feature requests or bug reports, please reach out to the AgentOps team on the AgentOps Repo.</p>"},{"location":"how-to/AgentOps-Observability/#extra-links","title":"Extra links","text":"<p>\ud83d\udc26 Twitter \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udce2 Discord \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udd87\ufe0f AgentOps Dashboard \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udcd9 Documentation</p>"},{"location":"how-to/Coding-Agents/","title":"Coding Agents","text":""},{"location":"how-to/Coding-Agents/#introduction","title":"Introduction","text":"<p>crewAI Agents now have the powerful ability to write and execute code, significantly enhancing their problem-solving capabilities. This feature is particularly useful for tasks that require computational or programmatic solutions.</p>"},{"location":"how-to/Coding-Agents/#enabling-code-execution","title":"Enabling Code Execution","text":"<p>To enable code execution for an agent, set the <code>allow_code_execution</code> parameter to <code>True</code> when creating the agent. Here's an example:</p> <pre><code>from crewai import Agent\n\ncoding_agent = Agent(\n    role=\"Senior Python Developer\",\n    goal=\"Craft well-designed and thought-out code\",\n    backstory=\"You are a senior Python developer with extensive experience in software architecture and best practices.\",\n    allow_code_execution=True\n)\n</code></pre> <p>Note: The <code>allow_code_execution</code> parameter defaults to <code>False</code>.</p>"},{"location":"how-to/Coding-Agents/#important-considerations","title":"Important Considerations","text":"<ol> <li> <p>Model Selection: It is strongly recommended to use more capable models like Claude 3.5 Sonnet and GPT-4 when enabling code execution. These models have a better understanding of programming concepts and are more likely to generate correct and efficient code.</p> </li> <li> <p>Error Handling: The code execution feature includes error handling. If executed code raises an exception, the agent will receive the error message and can attempt to correct the code or provide alternative solutions. The <code>max_retry_limit</code> parameter, which defaults to 2, controls the maximum number of retries for a task.</p> </li> <li> <p>Dependencies: To use the code execution feature, you need to install the <code>crewai_tools</code> package. If not installed, the agent will log an info message: \"Coding tools not available. Install crewai_tools.\"</p> </li> </ol>"},{"location":"how-to/Coding-Agents/#code-execution-process","title":"Code Execution Process","text":"<p>When an agent with code execution enabled encounters a task requiring programming:</p> <ol> <li>The agent analyzes the task and determines that code execution is necessary.</li> <li>It formulates the Python code needed to solve the problem.</li> <li>The code is sent to the internal code execution tool (<code>CodeInterpreterTool</code>).</li> <li>The tool executes the code in a controlled environment and returns the result.</li> <li>The agent interprets the result and incorporates it into its response or uses it for further problem-solving.</li> </ol>"},{"location":"how-to/Coding-Agents/#example-usage","title":"Example Usage","text":"<p>Here's a detailed example of creating an agent with code execution capabilities and using it in a task:</p> <pre><code>from crewai import Agent, Task, Crew\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants.\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Execute the crew\nresult = analysis_crew.kickoff()\n\nprint(result)\n</code></pre> <p>In this example, the <code>coding_agent</code> can write and execute Python code to perform data analysis tasks.</p>"},{"location":"how-to/Conditional-Tasks/","title":"Conditional Tasks","text":""},{"location":"how-to/Conditional-Tasks/#introduction","title":"Introduction","text":"<p>Conditional Tasks in crewAI allow for dynamic workflow adaptation based on the outcomes of previous tasks. This powerful feature enables crews to make decisions and execute tasks selectively, enhancing the flexibility and efficiency of your AI-driven processes.</p>"},{"location":"how-to/Conditional-Tasks/#example-usage","title":"Example Usage","text":"<pre><code>from typing import List\nfrom pydantic import BaseModel\nfrom crewai import Agent, Crew\nfrom crewai.tasks.conditional_task import ConditionalTask\nfrom crewai.tasks.task_output import TaskOutput\nfrom crewai.task import Task\nfrom crewai_tools import SerperDevTool\n\n# Define a condition function for the conditional task\n# If false, the task will be skipped, if true, then execute the task.\ndef is_data_missing(output: TaskOutput) -&gt; bool:\n    return len(output.pydantic.events) &lt; 10  # this will skip this task\n\n# Define the agents\ndata_fetcher_agent = Agent(\n    role=\"Data Fetcher\",\n    goal=\"Fetch data online using Serper tool\",\n    backstory=\"Backstory 1\",\n    verbose=True,\n    tools=[SerperDevTool()]\n)\n\ndata_processor_agent = Agent(\n    role=\"Data Processor\",\n    goal=\"Process fetched data\",\n    backstory=\"Backstory 2\",\n    verbose=True\n)\n\nsummary_generator_agent = Agent(\n    role=\"Summary Generator\",\n    goal=\"Generate summary from fetched data\",\n    backstory=\"Backstory 3\",\n    verbose=True\n)\n\nclass EventOutput(BaseModel):\n    events: List[str]\n\ntask1 = Task(\n    description=\"Fetch data about events in San Francisco using Serper tool\",\n    expected_output=\"List of 10 things to do in SF this week\",\n    agent=data_fetcher_agent,\n    output_pydantic=EventOutput,\n)\n\nconditional_task = ConditionalTask(\n    description=\"\"\"\n        Check if data is missing. If we have less than 10 events,\n        fetch more events using Serper tool so that\n        we have a total of 10 events in SF this week..\n        \"\"\",\n    expected_output=\"List of 10 Things to do in SF this week\",\n    condition=is_data_missing,\n    agent=data_processor_agent,\n)\n\ntask3 = Task(\n    description=\"Generate summary of events in San Francisco from fetched data\",\n    expected_output=\"A complete report on the customer and their customers and competitors, including their demographics, preferences, market positioning and audience engagement.\",\n    agent=summary_generator_agent,\n)\n\n# Create a crew with the tasks\ncrew = Crew(\n    agents=[data_fetcher_agent, data_processor_agent, summary_generator_agent],\n    tasks=[task1, conditional_task, task3],\n    verbose=True,\n    planning=True\n)\n\n# Run the crew\nresult = crew.kickoff()\nprint(\"results\", result)\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/","title":"Creating and Utilizing Tools in crewAI","text":""},{"location":"how-to/Create-Custom-Tools/#creating-and-utilizing-tools-in-crewai","title":"Creating and Utilizing Tools in crewAI","text":"<p>This guide provides detailed instructions on creating custom tools for the crewAI framework and how to efficiently manage and utilize these tools, incorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools, enabling agents to perform a wide range of actions.</p>"},{"location":"how-to/Create-Custom-Tools/#prerequisites","title":"Prerequisites","text":"<p>Before creating your own tools, ensure you have the crewAI extra tools package installed:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#subclassing-basetool","title":"Subclassing <code>BaseTool</code>","text":"<p>To create a personalized tool, inherit from <code>BaseTool</code> and define the necessary attributes and the <code>_run</code> method.</p> <pre><code>from crewai_tools import BaseTool\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n\n    def _run(self, argument: str) -&gt; str:\n        # Your tool's logic here\n        return \"Tool's result\"\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#using-the-tool-decorator","title":"Using the <code>tool</code> Decorator","text":"<p>Alternatively, you can use the tool decorator <code>@tool</code>. This approach allows you to define the tool's attributes and functionality directly within a function, offering a concise and efficient way to create specialized tools tailored to your needs.</p> <pre><code>from crewai_tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -&gt; str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#defining-a-cache-function-for-the-tool","title":"Defining a Cache Function for the Tool","text":"<p>To optimize tool performance with caching, define custom caching strategies using the <code>cache_function</code> attribute.</p> <pre><code>@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -&gt; str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cacheable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -&gt; bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy\n</code></pre> <p>By adhering to these guidelines and incorporating new functionalities and collaboration tools into your tool creation and management processes, you can leverage the full capabilities of the crewAI framework, enhancing both the development experience and the efficiency of your AI agents.</p>"},{"location":"how-to/Customize-Prompts/","title":"Initial Support to Bring Your Own Prompts in CrewAI","text":"<p>CrewAI now supports the ability to bring your own prompts, enabling extensive customization and internationalization. This feature allows users to tailor the inner workings of their agents to better suit specific needs, including support for multiple languages.</p>"},{"location":"how-to/Customize-Prompts/#internationalization-and-customization-support","title":"Internationalization and Customization Support","text":""},{"location":"how-to/Customize-Prompts/#custom-prompts-with-prompt_file","title":"Custom Prompts with <code>prompt_file</code>","text":"<p>The <code>prompt_file</code> attribute facilitates full customization of the agent prompts, enhancing the global usability of CrewAI. Users can specify their prompt templates, ensuring that the agents communicate in a manner that aligns with specific project requirements or language preferences.</p>"},{"location":"how-to/Customize-Prompts/#example-of-a-custom-prompt-file","title":"Example of a Custom Prompt File","text":"<p>The custom prompts can be defined in a JSON file, similar to the example provided here.</p>"},{"location":"how-to/Customize-Prompts/#supported-languages","title":"Supported Languages","text":"<p>CrewAI's custom prompt support includes internationalization, allowing prompts to be written in different languages. This is particularly useful for global teams or projects that require multilingual support.</p>"},{"location":"how-to/Customize-Prompts/#how-to-use-the-prompt_file-attribute","title":"How to Use the <code>prompt_file</code> Attribute","text":"<p>To utilize the <code>prompt_file</code> attribute, include it in your crew definition. Below is an example demonstrating how to set up agents and tasks with custom prompts.</p>"},{"location":"how-to/Customize-Prompts/#example","title":"Example","text":"<pre><code>import os\nfrom crewai import Agent, Task, Crew\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Make the best research and analysis on content about AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI and startups. You work as a freelancer and is now working on doing research and analysis for a new customer.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Write the best content about AI and AI agents.\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI and startups. You work as a freelancer and are now working on writing content for a new customer.\",\n    allow_delegation=False,\n)\n\n# Define your tasks\ntasks = [\n    Task(\n        description=\"Say Hi\",\n        expected_output=\"The word: Hi\",\n        agent=researcher,\n    )\n]\n\n# Instantiate your crew with custom prompts\ncrew = Crew(\n    agents=[researcher],\n    tasks=tasks,\n    prompt_file=\"prompt.json\",  # Path to your custom prompt file\n)\n\n# Get your crew to work!\ncrew.kickoff()\n</code></pre>"},{"location":"how-to/Customize-Prompts/#advanced-customization-features","title":"Advanced Customization Features","text":""},{"location":"how-to/Customize-Prompts/#language-attribute","title":"<code>language</code> Attribute","text":"<p>In addition to <code>prompt_file</code>, the <code>language</code> attribute can be used to specify the language for the agent's prompts. This ensures that the prompts are generated in the desired language, further enhancing the internationalization capabilities of CrewAI.</p>"},{"location":"how-to/Customize-Prompts/#creating-custom-prompt-files","title":"Creating Custom Prompt Files","text":"<p>Custom prompt files should be structured in JSON format and include all necessary prompt templates. Below is a simplified example of a prompt JSON file:</p> <pre><code>{\n    \"system\": \"You are a system template.\",\n    \"prompt\": \"Here is your prompt template.\",\n    \"response\": \"Here is your response template.\"\n}\n</code></pre>"},{"location":"how-to/Customize-Prompts/#benefits-of-custom-prompts","title":"Benefits of Custom Prompts","text":"<ul> <li>Enhanced Flexibility: Tailor agent communication to specific project needs.</li> <li>Improved Usability: Supports multiple languages, making it suitable for global projects.</li> <li>Consistency: Ensures uniform prompt structures across different agents and tasks.</li> </ul> <p>By incorporating these updates, CrewAI provides users with the ability to fully customize and internationalize their agent prompts, making the platform more versatile and user-friendly.</p>"},{"location":"how-to/Customizing-Agents/","title":"Customizing Agents in CrewAI","text":""},{"location":"how-to/Customizing-Agents/#customizable-attributes","title":"Customizable Attributes","text":"<p>Crafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize.</p>"},{"location":"how-to/Customizing-Agents/#key-attributes-for-customization","title":"Key Attributes for Customization","text":"<ul> <li>Role: Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.</li> <li>Goal: Defines what the agent aims to achieve, in alignment with its role and the overarching objectives of the crew.</li> <li>Backstory: Provides depth to the agent's persona, enriching its motivations and engagements within the crew.</li> <li>Tools (Optional): Represents the capabilities or methods the agent uses to perform tasks, from simple functions to intricate integrations.</li> <li>Cache (Optional): Determines whether the agent should use a cache for tool usage.</li> <li>Max RPM: Sets the maximum number of requests per minute (<code>max_rpm</code>). This attribute is optional and can be set to <code>None</code> for no limit, allowing for unlimited queries to external services if needed.</li> <li>Verbose (Optional): Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance.</li> <li>Allow Delegation (Optional): <code>allow_delegation</code> controls whether the agent is allowed to delegate tasks to other agents. This attribute is now set to <code>False</code> by default.</li> <li>Max Iter (Optional): The <code>max_iter</code> attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions. The default value is set to 25, providing a balance between thoroughness and efficiency.</li> <li>Max Execution Time (Optional): <code>max_execution_time</code> Sets the maximum execution time for an agent to complete a task.</li> <li>System Template (Optional): <code>system_template</code> defines the system format for the agent.</li> <li>Prompt Template (Optional): <code>prompt_template</code> defines the prompt format for the agent.</li> <li>Response Template (Optional): <code>response_template</code> defines the response format for the agent.</li> <li>Use System Prompt (Optional): <code>use_system_prompt</code> controls whether the agent will use a system prompt for task execution. Agents can now operate without system prompts.</li> <li>Respect Context Window: <code>respect_context_window</code> renames the sliding context window attribute and enables it by default to maintain context size.</li> <li>Max Retry Limit: <code>max_retry_limit</code> defines the maximum number of retries for an agent to execute a task when an error occurs.</li> </ul>"},{"location":"how-to/Customizing-Agents/#advanced-customization-options","title":"Advanced Customization Options","text":"<p>Beyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.</p>"},{"location":"how-to/Customizing-Agents/#language-model-customization","title":"Language Model Customization","text":"<p>Agents can be customized with specific language models (<code>llm</code>) and function-calling language models (<code>function_calling_llm</code>), offering advanced control over their processing and decision-making abilities. It's important to note that setting the <code>function_calling_llm</code> allows for overriding the default crew function-calling language model, providing a greater degree of customization.</p>"},{"location":"how-to/Customizing-Agents/#performance-and-debugging-settings","title":"Performance and Debugging Settings","text":"<p>Adjusting an agent's performance and monitoring its operations are crucial for efficient task execution.</p>"},{"location":"how-to/Customizing-Agents/#verbose-mode-and-rpm-limit","title":"Verbose Mode and RPM Limit","text":"<ul> <li>Verbose Mode: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance.</li> <li>RPM Limit: Sets the maximum number of requests per minute (<code>max_rpm</code>). This attribute is optional and can be set to <code>None</code> for no limit, allowing for unlimited queries to external services if needed.</li> </ul>"},{"location":"how-to/Customizing-Agents/#maximum-iterations-for-task-execution","title":"Maximum Iterations for Task Execution","text":"<p>The <code>max_iter</code> attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions. The default value is set to 25, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer.</p>"},{"location":"how-to/Customizing-Agents/#customizing-agents-and-tools","title":"Customizing Agents and Tools","text":"<p>Agents are customized by defining their attributes and tools during initialization. Tools are critical for an agent's functionality, enabling them to perform specialized tasks. The <code>tools</code> attribute should be an array of tools the agent can utilize, and it's initialized as an empty list by default. Tools can be added or modified post-agent initialization to adapt to new requirements.</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/Customizing-Agents/#example-assigning-tools-to-an-agent","title":"Example: Assigning Tools to an Agent","text":"<pre><code>import os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=25, # Default value for maximum iterations\n)\n</code></pre>"},{"location":"how-to/Customizing-Agents/#delegation-and-autonomy","title":"Delegation and Autonomy","text":"<p>Controlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default, the <code>allow_delegation</code> attribute is now set to <code>False</code>, disabling agents to seek assistance or delegate tasks as needed. This default behavior can be changed to promote collaborative problem-solving and efficiency within the CrewAI ecosystem. If needed, delegation can be enabled to suit specific operational requirements.</p>"},{"location":"how-to/Customizing-Agents/#example-disabling-delegation-for-an-agent","title":"Example: Disabling Delegation for an Agent","text":"<pre><code>agent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=True # Enabling delegation\n)\n</code></pre>"},{"location":"how-to/Customizing-Agents/#conclusion","title":"Conclusion","text":"<p>Customizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences, equips a nuanced and capable AI team ready for complex challenges.</p>"},{"location":"how-to/Force-Tool-Ouput-as-Result/","title":"Forcing Tool Output as Result","text":""},{"location":"how-to/Force-Tool-Ouput-as-Result/#introduction","title":"Introduction","text":"<p>In CrewAI, you can force the output of a tool as the result of an agent's task. This feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.</p>"},{"location":"how-to/Force-Tool-Ouput-as-Result/#forcing-tool-output-as-result","title":"Forcing Tool Output as Result","text":"<p>To force the tool output as the result of an agent's task, you need to set the <code>result_as_answer</code> parameter to <code>True</code> when adding a tool to the agent. This parameter ensures that the tool output is captured and returned as the task result, without any modifications by the agent.</p> <p>Here's an example of how to force the tool output as the result of an agent's task:</p> <pre><code># ...\nfrom crewai.agent import Agent\nfrom my_tool import MyCustomTool\n\n# Create a coding agent with the custom tool\ncoding_agent = Agent(\n        role=\"Data Scientist\",\n        goal=\"Produce amazing reports on AI\",\n        backstory=\"You work with data and AI\",\n        tools=[MyCustomTool(result_as_answer=True)],\n    )\n\n# Assuming the tool's execution and result population occurs within the system\ntask_result = coding_agent.execute_task(task)\n</code></pre>"},{"location":"how-to/Force-Tool-Ouput-as-Result/#workflow-in-action","title":"Workflow in Action","text":"<ol> <li>Task Execution: The agent executes the task using the tool provided.</li> <li>Tool Output: The tool generates the output, which is captured as the task result.</li> <li>Agent Interaction: The agent may reflect and take learnings from the tool but the output is not modified.</li> <li>Result Return: The tool output is returned as the task result without any modifications.</li> </ol>"},{"location":"how-to/Hierarchical/","title":"Implementing the Hierarchical Process in CrewAI","text":""},{"location":"how-to/Hierarchical/#introduction","title":"Introduction","text":"<p>The hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution. This systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.</p> <p>Complexity and Efficiency</p> <p>The hierarchical process is designed to leverage advanced models like GPT-4, optimizing token usage while handling complex tasks with greater efficiency.</p>"},{"location":"how-to/Hierarchical/#hierarchical-process-overview","title":"Hierarchical Process Overview","text":"<p>By default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management, where a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent can now be either automatically created by CrewAI or explicitly set by the user.</p>"},{"location":"how-to/Hierarchical/#key-features","title":"Key Features","text":"<ul> <li>Task Delegation: A manager agent allocates tasks among crew members based on their roles and capabilities.</li> <li>Result Validation: The manager evaluates outcomes to ensure they meet the required standards.</li> <li>Efficient Workflow: Emulates corporate structures, providing an organized approach to task management.</li> <li>System Prompt Handling: Optionally specify whether the system should use predefined prompts.</li> <li>Stop Words Control: Optionally specify whether stop words should be used, supporting various models including the o1 models.</li> <li>Context Window Respect: Prioritize important context by enabling respect of the context window, which is now the default behavior.</li> <li>Delegation Control: Delegation is now disabled by default to give users explicit control.</li> <li>Max Requests Per Minute: Configurable option to set the maximum number of requests per minute.</li> <li>Max Iterations: Limit the maximum number of iterations for obtaining a final answer.</li> </ul>"},{"location":"how-to/Hierarchical/#implementing-the-hierarchical-process","title":"Implementing the Hierarchical Process","text":"<p>To utilize the hierarchical process, it's essential to explicitly set the process attribute to <code>Process.hierarchical</code>, as the default behavior is <code>Process.sequential</code>. Define a crew with a designated manager and establish a clear chain of command.</p> <p>Tools and Agent Assignment</p> <p>Assign tools at the agent level to facilitate task delegation and execution by the designated agents under the manager's guidance. Tools can also be specified at the task level for precise control over tool availability during task execution.</p> <p>Manager LLM Requirement</p> <p>Configuring the <code>manager_llm</code> parameter is crucial for the hierarchical process. The system requires a manager LLM to be set up for proper function, ensuring tailored decision-making.</p> <pre><code>from langchain_openai import ChatOpenAI\nfrom crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n    cache=True,\n    verbose=False,\n    # tools=[]  # This can be optionally specified; defaults to an empty list\n    use_system_prompt=True,  # Enable or disable system prompts for this agent\n    max_rpm=30,  # Limit on the number of requests per minute\n    max_iter=5  # Maximum number of iterations for a final answer\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n    cache=True,\n    verbose=False,\n    # tools=[]  # Optionally specify tools; defaults to an empty list\n    use_system_prompt=True,  # Enable or disable system prompts for this agent\n    max_rpm=30,  # Limit on the number of requests per minute\n    max_iter=5  # Maximum number of iterations for a final answer\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=ChatOpenAI(temperature=0, model=\"gpt-4\"),  # Mandatory if manager_agent is not set\n    process=Process.hierarchical,  # Specifies the hierarchical management approach\n    respect_context_window=True,  # Enable respect of the context window for tasks\n    memory=True,  # Enable memory usage for enhanced task execution\n    manager_agent=None,  # Optional: explicitly set a specific agent as manager instead of the manager_llm\n    planning=True,  # Enable planning feature for pre-execution strategy\n)\n</code></pre>"},{"location":"how-to/Hierarchical/#workflow-in-action","title":"Workflow in Action","text":"<ol> <li>Task Assignment: The manager assigns tasks strategically, considering each agent's capabilities and available tools.</li> <li>Execution and Review: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows.</li> <li>Sequential Task Progression: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.</li> </ol>"},{"location":"how-to/Hierarchical/#conclusion","title":"Conclusion","text":"<p>Adopting the hierarchical process in CrewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management. Utilize the advanced features and customizations to tailor the workflow to your specific needs, ensuring optimal task execution and project success.</p>"},{"location":"how-to/Human-Input-on-Execution/","title":"Human Input in Agent Execution","text":"<p>Human input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary. This feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively.</p>"},{"location":"how-to/Human-Input-on-Execution/#using-human-input-with-crewai","title":"Using Human Input with CrewAI","text":"<p>To integrate human input into agent execution, set the <code>human_input</code> flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer. This input can provide extra context, clarify ambiguities, or validate the agent's output.</p>"},{"location":"how-to/Human-Input-on-Execution/#example","title":"Example:","text":"<pre><code>pip install crewai\n</code></pre> <pre><code>import os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=(\n        \"You are a Senior Research Analyst at a leading tech think tank. \"\n        \"Your expertise lies in identifying emerging trends and technologies in AI and data science. \"\n        \"You have a knack for dissecting complex data and presenting actionable insights.\"\n    ),\n    verbose=True,\n    allow_delegation=False,\n    tools=[search_tool]\n)\nwriter = Agent(\n    role='Tech Content Strategist',\n    goal='Craft compelling content on tech advancements',\n    backstory=(\n        \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation. \"\n        \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n    ),\n    verbose=True,\n    allow_delegation=True,\n    tools=[search_tool],\n    cache=False,  # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n    description=(\n        \"Conduct a comprehensive analysis of the latest advancements in AI in 2024. \"\n        \"Identify key trends, breakthrough technologies, and potential industry impacts. \"\n        \"Compile your findings in a detailed report. \"\n        \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n    ),\n    expected_output='A comprehensive full report on the latest AI advancements in 2024, leave nothing out',\n    agent=researcher,\n    human_input=True\n)\n\ntask2 = Task(\n    description=(\n        \"Using the insights from the researcher\\'s report, develop an engaging blog post that highlights the most significant AI advancements. \"\n        \"Your post should be informative yet accessible, catering to a tech-savvy audience. \"\n        \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n    ),\n    expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2024',\n    agent=writer,\n    human_input=True\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task1, task2],\n    verbose=True,\n    memory=True,\n    planning=True  # Enable planning feature for the crew\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)\n</code></pre>"},{"location":"how-to/Kickoff-async/","title":"Kickoff Async","text":""},{"location":"how-to/Kickoff-async/#introduction","title":"Introduction","text":"<p>CrewAI provides the ability to kickoff a crew asynchronously, allowing you to start the crew execution in a non-blocking manner. This feature is particularly useful when you want to run multiple crews concurrently or when you need to perform other tasks while the crew is executing.</p>"},{"location":"how-to/Kickoff-async/#asynchronous-crew-execution","title":"Asynchronous Crew Execution","text":"<p>To kickoff a crew asynchronously, use the <code>kickoff_async()</code> method. This method initiates the crew execution in a separate thread, allowing the main thread to continue executing other tasks.</p>"},{"location":"how-to/Kickoff-async/#method-signature","title":"Method Signature","text":"<pre><code>def kickoff_async(self, inputs: dict) -&gt; CrewOutput:\n</code></pre>"},{"location":"how-to/Kickoff-async/#parameters","title":"Parameters","text":"<ul> <li><code>inputs</code> (dict): A dictionary containing the input data required for the tasks.</li> </ul>"},{"location":"how-to/Kickoff-async/#returns","title":"Returns","text":"<ul> <li><code>CrewOutput</code>: An object representing the result of the crew execution.</li> </ul>"},{"location":"how-to/Kickoff-async/#potential-use-cases","title":"Potential Use Cases","text":"<ul> <li> <p>Parallel Content Generation: Kickoff multiple independent crews asynchronously, each responsible for generating content on different topics. For example, one crew might research and draft an article on AI trends, while another crew generates social media posts about a new product launch. Each crew operates independently, allowing content production to scale efficiently.</p> </li> <li> <p>Concurrent Market Research Tasks: Launch multiple crews asynchronously to conduct market research in parallel. One crew might analyze industry trends, while another examines competitor strategies, and yet another evaluates consumer sentiment. Each crew independently completes its task, enabling faster and more comprehensive insights.</p> </li> <li> <p>Independent Travel Planning Modules: Execute separate crews to independently plan different aspects of a trip. One crew might handle flight options, another handles accommodation, and a third plans activities. Each crew works asynchronously, allowing various components of the trip to be planned simultaneously and independently for faster results.</p> </li> </ul>"},{"location":"how-to/Kickoff-async/#example-single-asynchronous-crew-execution","title":"Example: Single Asynchronous Crew Execution","text":"<p>Here's an example of how to kickoff a crew asynchronously using asyncio and awaiting the result:</p> <pre><code>import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task]\n)\n\n# Async function to kickoff the crew asynchronously\nasync def async_crew_execution():\n    result = await analysis_crew.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    print(\"Crew Result:\", result)\n\n# Run the async function\nasyncio.run(async_crew_execution())\n</code></pre>"},{"location":"how-to/Kickoff-async/#example-multiple-asynchronous-crew-executions","title":"Example: Multiple Asynchronous Crew Executions","text":"<p>In this example, we'll show how to kickoff multiple crews asynchronously and wait for all of them to complete using <code>asyncio.gather()</code>:</p> <pre><code>import asyncio\nfrom crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create tasks that require code execution\ntask_1 = Task(\n    description=\"Analyze the first dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\ntask_2 = Task(\n    description=\"Analyze the second dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent\n)\n\n# Create two crews and add tasks\ncrew_1 = Crew(agents=[coding_agent], tasks=[task_1])\ncrew_2 = Crew(agents=[coding_agent], tasks=[task_2])\n\n# Async function to kickoff multiple crews asynchronously and wait for all to finish\nasync def async_multiple_crews():\n    result_1 = crew_1.kickoff_async(inputs={\"ages\": [25, 30, 35, 40, 45]})\n    result_2 = crew_2.kickoff_async(inputs={\"ages\": [20, 22, 24, 28, 30]})\n\n    # Wait for both crews to finish\n    results = await asyncio.gather(result_1, result_2)\n\n    for i, result in enumerate(results, 1):\n        print(f\"Crew {i} Result:\", result)\n\n# Run the async function\nasyncio.run(async_multiple_crews())\n</code></pre>"},{"location":"how-to/Kickoff-for-each/","title":"Kickoff For Each","text":""},{"location":"how-to/Kickoff-for-each/#introduction","title":"Introduction","text":"<p>CrewAI provides the ability to kickoff a crew for each item in a list, allowing you to execute the crew for each item in the list. This feature is particularly useful when you need to perform the same set of tasks for multiple items.</p>"},{"location":"how-to/Kickoff-for-each/#kicking-off-a-crew-for-each-item","title":"Kicking Off a Crew for Each Item","text":"<p>To kickoff a crew for each item in a list, use the <code>kickoff_for_each()</code> method. This method executes the crew for each item in the list, allowing you to process multiple items efficiently.</p> <p>Here's an example of how to kickoff a crew for each item in a list:</p> <pre><code>from crewai import Crew, Agent, Task\n\n# Create an agent with code execution enabled\ncoding_agent = Agent(\n    role=\"Python Data Analyst\",\n    goal=\"Analyze data and provide insights using Python\",\n    backstory=\"You are an experienced data analyst with strong Python skills.\",\n    allow_code_execution=True\n)\n\n# Create a task that requires code execution\ndata_analysis_task = Task(\n    description=\"Analyze the given dataset and calculate the average age of participants. Ages: {ages}\",\n    agent=coding_agent,\n    expected_output=\"The average age calculated from the dataset\"\n)\n\n# Create a crew and add the task\nanalysis_crew = Crew(\n    agents=[coding_agent],\n    tasks=[data_analysis_task],\n    verbose=True,\n    memory=False,\n    respect_context_window=True  # enable by default\n)\n\ndatasets = [\n  { \"ages\": [25, 30, 35, 40, 45] },\n  { \"ages\": [20, 25, 30, 35, 40] },\n  { \"ages\": [30, 35, 40, 45, 50] }\n]\n\n# Execute the crew\nresult = analysis_crew.kickoff_for_each(inputs=datasets)\n</code></pre>"},{"location":"how-to/LLM-Connections/","title":"Connect CrewAI to LLMs","text":""},{"location":"how-to/LLM-Connections/#connect-crewai-to-llms","title":"Connect CrewAI to LLMs","text":"<p>CrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.</p> <p>Default LLM</p> <p>By default, CrewAI uses the <code>gpt-4o-mini</code> model. This is determined by the <code>OPENAI_MODEL_NAME</code> environment variable, which defaults to \"gpt-4o-mini\" if not set. You can easily configure your agents to use a different model or provider as described in this guide.</p>"},{"location":"how-to/LLM-Connections/#supported-providers","title":"Supported Providers","text":"<p>LiteLLM supports a wide range of providers, including but not limited to:</p> <ul> <li>OpenAI</li> <li>Anthropic</li> <li>Google (Vertex AI, Gemini)</li> <li>Azure OpenAI</li> <li>AWS (Bedrock, SageMaker)</li> <li>Cohere</li> <li>Hugging Face</li> <li>Ollama</li> <li>Mistral AI</li> <li>Replicate</li> <li>Together AI</li> <li>AI21</li> <li>Cloudflare Workers AI</li> <li>DeepInfra</li> <li>Groq</li> <li>And many more!</li> </ul> <p>For a complete and up-to-date list of supported providers, please refer to the LiteLLM Providers documentation.</p>"},{"location":"how-to/LLM-Connections/#changing-the-llm","title":"Changing the LLM","text":"<p>To use a different LLM with your CrewAI agents, you have several options:</p>"},{"location":"how-to/LLM-Connections/#1-using-a-string-identifier","title":"1. Using a String Identifier","text":"<p>Pass the model name as a string when initializing the agent:</p> <pre><code>from crewai import Agent\n\n# Using OpenAI's GPT-4\nopenai_agent = Agent(\n    role='OpenAI Expert',\n    goal='Provide insights using GPT-4',\n    backstory=\"An AI assistant powered by OpenAI's latest model.\",\n    llm='gpt-4'\n)\n\n# Using Anthropic's Claude\nclaude_agent = Agent(\n    role='Anthropic Expert',\n    goal='Analyze data using Claude',\n    backstory=\"An AI assistant leveraging Anthropic's language model.\",\n    llm='claude-2'\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#2-using-the-llm-class","title":"2. Using the LLM Class","text":"<p>For more detailed configuration, use the LLM class:</p> <pre><code>from crewai import Agent, LLM\n\nllm = LLM(\n    model=\"gpt-4\",\n    temperature=0.7,\n    base_url=\"https://api.openai.com/v1\",\n    api_key=\"your-api-key-here\"\n)\n\nagent = Agent(\n    role='Customized LLM Expert',\n    goal='Provide tailored responses',\n    backstory=\"An AI assistant with custom LLM settings.\",\n    llm=llm\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#configuration-options","title":"Configuration Options","text":"<p>When configuring an LLM for your agent, you have access to a wide range of parameters:</p> Parameter Type Description <code>model</code> str The name of the model to use (e.g., \"gpt-4\", \"claude-2\") <code>temperature</code> float Controls randomness in output (0.0 to 1.0) <code>max_tokens</code> int Maximum number of tokens to generate <code>top_p</code> float Controls diversity of output (0.0 to 1.0) <code>frequency_penalty</code> float Penalizes new tokens based on their frequency in the text so far <code>presence_penalty</code> float Penalizes new tokens based on their presence in the text so far <code>stop</code> str, List[str] Sequence(s) to stop generation <code>base_url</code> str The base URL for the API endpoint <code>api_key</code> str Your API key for authentication <p>For a complete list of parameters and their descriptions, refer to the LLM class documentation.</p>"},{"location":"how-to/LLM-Connections/#connecting-to-openai-compatible-llms","title":"Connecting to OpenAI-Compatible LLMs","text":"<p>You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:</p>"},{"location":"how-to/LLM-Connections/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code>import os\n\nos.environ[\"OPENAI_API_KEY\"] = \"your-api-key\"\nos.environ[\"OPENAI_API_BASE\"] = \"https://api.your-provider.com/v1\"\nos.environ[\"OPENAI_MODEL_NAME\"] = \"your-model-name\"\n</code></pre>"},{"location":"how-to/LLM-Connections/#using-llm-class-attributes","title":"Using LLM Class Attributes","text":"<pre><code>llm = LLM(\n    model=\"custom-model-name\",\n    api_key=\"your-api-key\",\n    base_url=\"https://api.your-provider.com/v1\"\n)\nagent = Agent(llm=llm, ...)\n</code></pre>"},{"location":"how-to/LLM-Connections/#using-local-models-with-ollama","title":"Using Local Models with Ollama","text":"<p>For local models like those provided by Ollama:</p> <ol> <li>Download and install Ollama</li> <li>Pull the desired model (e.g., <code>ollama pull llama2</code>)</li> <li>Configure your agent:</li> </ol> <pre><code>agent = Agent(\n    role='Local AI Expert',\n    goal='Process information using a local model',\n    backstory=\"An AI assistant running on local hardware.\",\n    llm=LLM(model=\"ollama/llama2\", base_url=\"http://localhost:11434\")\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#changing-the-base-api-url","title":"Changing the Base API URL","text":"<p>You can change the base API URL for any LLM provider by setting the <code>base_url</code> parameter:</p> <pre><code>llm = LLM(\n    model=\"custom-model-name\",\n    base_url=\"https://api.your-provider.com/v1\",\n    api_key=\"your-api-key\"\n)\nagent = Agent(llm=llm, ...)\n</code></pre> <p>This is particularly useful when working with OpenAI-compatible APIs or when you need to specify a different endpoint for your chosen provider.</p>"},{"location":"how-to/LLM-Connections/#conclusion","title":"Conclusion","text":"<p>By leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the LiteLLM documentation for the most up-to-date information on supported models and configuration options.</p>"},{"location":"how-to/Langtrace-Observability/","title":"Langtrace Overview","text":"<p>Langtrace is an open-source, external tool that helps you set up observability and evaluations for Large Language Models (LLMs), LLM frameworks, and Vector Databases. While not built directly into CrewAI, Langtrace can be used alongside CrewAI to gain deep visibility into the cost, latency, and performance of your CrewAI Agents. This integration allows you to log hyperparameters, monitor performance regressions, and establish a process for continuous improvement of your Agents.</p> <p> </p>"},{"location":"how-to/Langtrace-Observability/#setup-instructions","title":"Setup Instructions","text":"<ol> <li>Sign up for Langtrace by visiting https://langtrace.ai/signup.</li> <li>Create a project, set the project type to crewAI &amp; generate an API key.</li> <li>Install Langtrace in your CrewAI project using the following commands:</li> </ol> <pre><code># Install the SDK\npip install langtrace-python-sdk\n</code></pre>"},{"location":"how-to/Langtrace-Observability/#using-langtrace-with-crewai","title":"Using Langtrace with CrewAI","text":"<p>To integrate Langtrace with your CrewAI project, follow these steps:</p> <ol> <li>Import and initialize Langtrace at the beginning of your script, before any CrewAI imports:</li> </ol> <pre><code>from langtrace_python_sdk import langtrace\nlangtrace.init(api_key='&lt;LANGTRACE_API_KEY&gt;')\n\n# Now import CrewAI modules\nfrom crewai import Agent, Task, Crew\n</code></pre>"},{"location":"how-to/Langtrace-Observability/#features-and-their-application-to-crewai","title":"Features and Their Application to CrewAI","text":"<ol> <li> <p>LLM Token and Cost Tracking</p> </li> <li> <p>Monitor the token usage and associated costs for each CrewAI agent interaction.</p> </li> <li> <p>Trace Graph for Execution Steps</p> </li> <li> <p>Visualize the execution flow of your CrewAI tasks, including latency and logs.</p> </li> <li> <p>Useful for identifying bottlenecks in your agent workflows.</p> </li> <li> <p>Dataset Curation with Manual Annotation</p> </li> <li> <p>Create datasets from your CrewAI task outputs for future training or evaluation.</p> </li> <li> <p>Prompt Versioning and Management</p> </li> <li> <p>Keep track of different versions of prompts used in your CrewAI agents.</p> </li> <li> <p>Useful for A/B testing and optimizing agent performance.</p> </li> <li> <p>Prompt Playground with Model Comparisons</p> </li> <li> <p>Test and compare different prompts and models for your CrewAI agents before deployment.</p> </li> <li> <p>Testing and Evaluations</p> </li> <li>Set up automated tests for your CrewAI agents and tasks.</li> </ol>"},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/","title":"Replay Tasks from Latest Crew Kickoff","text":""},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/#introduction","title":"Introduction","text":"<p>CrewAI provides the ability to replay from a task specified from the latest crew kickoff. This feature is particularly useful when you've finished a kickoff and may want to retry certain tasks or don't need to refetch data over and your agents already have the context saved from the kickoff execution so you just need to replay the tasks you want to.</p>"},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/#note","title":"Note:","text":"<p>You must run <code>crew.kickoff()</code> before you can replay a task. Currently, only the latest kickoff is supported, so if you use <code>kickoff_for_each</code>, it will only allow you to replay from the most recent crew run.</p> <p>Here's an example of how to replay from a task:</p>"},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/#replaying-from-specific-task-using-the-cli","title":"Replaying from Specific Task Using the CLI","text":"<p>To use the replay feature, follow these steps:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Navigate to the directory where your CrewAI project is located.</li> <li>Run the following commands:</li> </ol> <p>To view the latest kickoff task_ids use: <pre><code>crewai log-tasks-outputs\n</code></pre></p> <p>Once you have your <code>task_id</code> to replay, use: <pre><code>crewai replay -t &lt;task_id&gt;\n</code></pre></p> <p>Note: Ensure <code>crewai</code> is installed and configured correctly in your development environment.</p>"},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/#replaying-from-a-task-programmatically","title":"Replaying from a Task Programmatically","text":"<p>To replay from a task programmatically, use the following steps:</p> <ol> <li>Specify the <code>task_id</code> and input parameters for the replay process.</li> <li>Execute the replay command within a try-except block to handle potential errors.</li> </ol> <pre><code>  def replay():\n    \"\"\"\n    Replay the crew execution from a specific task.\n    \"\"\"\n    task_id = '&lt;task_id&gt;'\n    inputs = {\"topic\": \"CrewAI Training\"}  # This is optional; you can pass in the inputs you want to replay; otherwise, it uses the previous kickoff's inputs.\n    try:\n        YourCrewName_Crew().crew().replay(task_id=task_id, inputs=inputs)\n\n    except subprocess.CalledProcessError as e:\n        raise Exception(f\"An error occurred while replaying the crew: {e}\")\n\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: {e}\")\n</code></pre>"},{"location":"how-to/Replay-tasks-from-latest-Crew-Kickoff/#conclusion","title":"Conclusion","text":"<p>With the above enhancements and detailed functionality, replaying specific tasks in CrewAI has been made more efficient and robust. Ensure you follow the commands and steps precisely to make the most of these features.</p>"},{"location":"how-to/Sequential/","title":"Using the Sequential Processes in crewAI","text":""},{"location":"how-to/Sequential/#introduction","title":"Introduction","text":"<p>CrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes. This guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.</p>"},{"location":"how-to/Sequential/#sequential-process-overview","title":"Sequential Process Overview","text":"<p>The sequential process ensures tasks are executed one after the other, following a linear progression. This approach is ideal for projects requiring tasks to be completed in a specific order.</p>"},{"location":"how-to/Sequential/#key-features","title":"Key Features","text":"<ul> <li>Linear Task Flow: Ensures orderly progression by handling tasks in a predetermined sequence.</li> <li>Simplicity: Best suited for projects with clear, step-by-step tasks.</li> <li>Easy Monitoring: Facilitates easy tracking of task completion and project progress.</li> </ul>"},{"location":"how-to/Sequential/#implementing-the-sequential-process","title":"Implementing the Sequential Process","text":"<p>To use the sequential process, assemble your crew and define tasks in the order they need to be executed.</p> <pre><code>from crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define your tasks\nresearch_task = Task(description='Gather relevant data...', agent=researcher, expected_output='Raw Data')\nanalysis_task = Task(description='Analyze the data...', agent=analyst, expected_output='Data Insights')\nwriting_task = Task(description='Compose the report...', agent=writer, expected_output='Final Report')\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n\n# Execute the crew\nresult = report_crew.kickoff()\n\n# Accessing the type-safe output\ntask_output: TaskOutput = result.tasks[0].output\ncrew_output: CrewOutput = result.output\n</code></pre>"},{"location":"how-to/Sequential/#note","title":"Note:","text":"<p>Each task in a sequential process must have an agent assigned. Ensure that every <code>Task</code> includes an <code>agent</code> parameter.</p>"},{"location":"how-to/Sequential/#workflow-in-action","title":"Workflow in Action","text":"<ol> <li>Initial Task: In a sequential process, the first agent completes their task and signals completion.</li> <li>Subsequent Tasks: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or directives guiding their execution.</li> <li>Completion: The process concludes once the final task is executed, leading to project completion.</li> </ol>"},{"location":"how-to/Sequential/#advanced-features","title":"Advanced Features","text":""},{"location":"how-to/Sequential/#task-delegation","title":"Task Delegation","text":"<p>In sequential processes, if an agent has <code>allow_delegation</code> set to <code>True</code>, they can delegate tasks to other agents in the crew. This feature is automatically set up when there are multiple agents in the crew.</p>"},{"location":"how-to/Sequential/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>Tasks can be executed asynchronously, allowing for parallel processing when appropriate. To create an asynchronous task, set <code>async_execution=True</code> when defining the task.</p>"},{"location":"how-to/Sequential/#memory-and-caching","title":"Memory and Caching","text":"<p>CrewAI supports both memory and caching features: - Memory: Enable by setting <code>memory=True</code> when creating the Crew. This allows agents to retain information across tasks. - Caching: By default, caching is enabled. Set <code>cache=False</code> to disable it.</p>"},{"location":"how-to/Sequential/#callbacks","title":"Callbacks","text":"<p>You can set callbacks at both the task and step level: - <code>task_callback</code>: Executed after each task completion. - <code>step_callback</code>: Executed after each step in an agent's execution.</p>"},{"location":"how-to/Sequential/#usage-metrics","title":"Usage Metrics","text":"<p>CrewAI tracks token usage across all tasks and agents. You can access these metrics after execution.</p>"},{"location":"how-to/Sequential/#best-practices-for-sequential-processes","title":"Best Practices for Sequential Processes","text":"<ol> <li>Order Matters: Arrange tasks in a logical sequence where each task builds upon the previous one.</li> <li>Clear Task Descriptions: Provide detailed descriptions for each task to guide the agents effectively.</li> <li>Appropriate Agent Selection: Match agents' skills and roles to the requirements of each task.</li> <li>Use Context: Leverage the context from previous tasks to inform subsequent ones.</li> </ol> <p>This updated documentation ensures that details accurately reflect the latest changes in the codebase and clearly describes how to leverage new features and configurations. The content is kept simple and direct to ensure easy understanding.</p>"},{"location":"how-to/Your-Own-Manager-Agent/","title":"Setting a Specific Agent as Manager in CrewAI","text":"<p>CrewAI allows users to set a specific agent as the manager of the crew, providing more control over the management and coordination of tasks. This feature enables the customization of the managerial role to better fit your project's requirements.</p>"},{"location":"how-to/Your-Own-Manager-Agent/#using-the-manager_agent-attribute","title":"Using the <code>manager_agent</code> Attribute","text":""},{"location":"how-to/Your-Own-Manager-Agent/#custom-manager-agent","title":"Custom Manager Agent","text":"<p>The <code>manager_agent</code> attribute allows you to define a custom agent to manage the crew. This agent will oversee the entire process, ensuring that tasks are completed efficiently and to the highest standard.</p>"},{"location":"how-to/Your-Own-Manager-Agent/#example","title":"Example","text":"<pre><code>import os\nfrom crewai import Agent, Task, Crew, Process\n\n# Define your agents\nresearcher = Agent(\n    role=\"Researcher\",\n    goal=\"Conduct thorough research and analysis on AI and AI agents\",\n    backstory=\"You're an expert researcher, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently researching for a new client.\",\n    allow_delegation=False,\n)\n\nwriter = Agent(\n    role=\"Senior Writer\",\n    goal=\"Create compelling content about AI and AI agents\",\n    backstory=\"You're a senior writer, specialized in technology, software engineering, AI, and startups. You work as a freelancer and are currently writing content for a new client.\",\n    allow_delegation=False,\n)\n\n# Define your task\ntask = Task(\n    description=\"Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.\",\n    expected_output=\"5 bullet points, each with a paragraph and accompanying notes.\",\n)\n\n# Define the manager agent\nmanager = Agent(\n    role=\"Project Manager\",\n    goal=\"Efficiently manage the crew and ensure high-quality task completion\",\n    backstory=\"You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.\",\n    allow_delegation=True,\n)\n\n# Instantiate your crew with a custom manager\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    manager_agent=manager,\n    process=Process.hierarchical,\n)\n\n# Start the crew's work\nresult = crew.kickoff()\n</code></pre>"},{"location":"how-to/Your-Own-Manager-Agent/#benefits-of-a-custom-manager-agent","title":"Benefits of a Custom Manager Agent","text":"<ul> <li>Enhanced Control: Tailor the management approach to fit the specific needs of your project.</li> <li>Improved Coordination: Ensure efficient task coordination and management by an experienced agent.</li> <li>Customizable Management: Define managerial roles and responsibilities that align with your project's goals.</li> </ul>"},{"location":"how-to/Your-Own-Manager-Agent/#setting-a-manager-llm","title":"Setting a Manager LLM","text":"<p>If you're using the hierarchical process and don't want to set a custom manager agent, you can specify the language model for the manager:</p> <pre><code>from langchain_openai import ChatOpenAI\n\nmanager_llm = ChatOpenAI(model_name=\"gpt-4\")\n\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[task],\n    process=Process.hierarchical,\n    manager_llm=manager_llm\n)\n</code></pre> <p>Note: Either <code>manager_agent</code> or <code>manager_llm</code> must be set when using the hierarchical process.</p>"},{"location":"telemetry/Telemetry/","title":"Telemetry","text":""},{"location":"telemetry/Telemetry/#telemetry","title":"Telemetry","text":"<p>Personal Information</p> <p>By default, we collect no data that would be considered personal information under GDPR and other privacy regulations. We do collect Tool's names and Agent's roles, so be advised not to include any personal information in the tool's names or the Agent's roles.     Because no personal information is collected, it's not necessary to worry about data residency.     When <code>share_crew</code> is enabled, additional data is collected which may contain personal information if included by the user. Users should exercise caution when enabling this feature to ensure compliance with privacy regulations.</p> <p>CrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library. Our focus is on improving and developing the features, integrations, and tools most utilized by our users.</p> <p>It's pivotal to understand that by default, NO personal data is collected concerning prompts, task descriptions, agents' backstories or goals, usage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables. When the <code>share_crew</code> feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected to provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks. Users should carefully consider the content of their crews and tasks before enabling <code>share_crew</code>. Users can disable telemetry by setting the environment variable OTEL_SDK_DISABLED to true.</p>"},{"location":"telemetry/Telemetry/#data-explanation","title":"Data Explanation:","text":"Defaulted Data Reason and Specifics Yes CrewAI and Python Version Tracks software versions. Example: CrewAI v1.2.3, Python 3.8.10. No personal data. Yes Crew Metadata Includes: randomly generated key and ID, process type (e.g., 'sequential', 'parallel'), boolean flag for memory usage (true/false), count of tasks, count of agents. All non-personal. Yes Agent Data Includes: randomly generated key and ID, role name (should not include personal info), boolean settings (verbose, delegation enabled, code execution allowed), max iterations, max RPM, max retry limit, LLM info (see LLM Attributes), list of tool names (should not include personal info). No personal data. Yes Task Metadata Includes: randomly generated key and ID, boolean execution settings (async_execution, human_input), associated agent's role and key, list of tool names. All non-personal. Yes Tool Usage Statistics Includes: tool name (should not include personal info), number of usage attempts (integer), LLM attributes used. No personal data. Yes Test Execution Data Includes: crew's randomly generated key and ID, number of iterations, model name used, quality score (float), execution time (in seconds). All non-personal. Yes Task Lifecycle Data Includes: creation and execution start/end times, crew and task identifiers. Stored as spans with timestamps. No personal data. Yes LLM Attributes Includes: name, model_name, model, top_k, temperature, and class name of the LLM. All technical, non-personal data. Yes Crew Deployment attempt using crewAI CLI Includes: The fact a deploy is being made and crew id, and if it's trying to pull logs, no other data. No Agent's Expanded Data Includes: goal description, backstory text, i18n prompt file identifier. Users should ensure no personal info is included in text fields. No Detailed Task Information Includes: task description, expected output description, context references. Users should ensure no personal info is included in these fields. No Environment Information Includes: platform, release, system, version, and CPU count. Example: 'Windows 10', 'x86_64'. No personal data. No Crew and Task Inputs and Outputs Includes: input parameters and output results as non-identifiable data. Users should ensure no personal info is included. No Comprehensive Crew Execution Data Includes: detailed logs of crew operations, all agents and tasks data, final output. All non-personal and technical in nature. <p>Note: \"No\" in the \"Defaulted\" column indicates that this data is only collected when <code>share_crew</code> is set to <code>true</code>.</p>"},{"location":"telemetry/Telemetry/#opt-in-further-telemetry-sharing","title":"Opt-In Further Telemetry Sharing","text":"<p>Users can choose to share their complete telemetry data by enabling the <code>share_crew</code> attribute to <code>True</code> in their crew configurations. Enabling <code>share_crew</code> results in the collection of detailed crew and task execution data, including <code>goal</code>, <code>backstory</code>, <code>context</code>, and <code>output</code> of tasks. This enables a deeper insight into usage patterns.</p> <p>Potential Personal Information</p> <p>If you enable <code>share_crew</code>, the collected data may include personal information if it has been incorporated into crew configurations, task descriptions, or outputs. Users should carefully review their data and ensure compliance with GDPR and other applicable privacy regulations before enabling this feature.</p>"},{"location":"tools/BrowserbaseLoadTool/","title":"BrowserbaseLoadTool","text":""},{"location":"tools/BrowserbaseLoadTool/#description","title":"Description","text":"<p>Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.</p> <p>Power your AI data retrievals with:  - Serverless Infrastructure providing reliable browsers to extract data from complex UIs  - Stealth Mode with included fingerprinting tactics and automatic captcha solving  - Session Debugger to inspect your Browser Session with networks timeline and logs  - Live Debug to quickly debug your automation</p>"},{"location":"tools/BrowserbaseLoadTool/#installation","title":"Installation","text":"<ul> <li>Get an API key and Project ID from browserbase.com and set it in environment variables (<code>BROWSERBASE_API_KEY</code>, <code>BROWSERBASE_PROJECT_ID</code>).</li> <li>Install the Browserbase SDK along with <code>crewai[tools]</code> package:</li> </ul> <pre><code>pip install browserbase 'crewai[tools]'\n</code></pre>"},{"location":"tools/BrowserbaseLoadTool/#example","title":"Example","text":"<p>Utilize the BrowserbaseLoadTool as follows to allow your agent to load websites:</p> <pre><code>from crewai_tools import BrowserbaseLoadTool\n\ntool = BrowserbaseLoadTool()\n</code></pre>"},{"location":"tools/BrowserbaseLoadTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code> Optional. Browserbase API key. Default is <code>BROWSERBASE_API_KEY</code> env variable.</li> <li><code>project_id</code> Optional. Browserbase Project ID. Default is <code>BROWSERBASE_PROJECT_ID</code> env variable.</li> <li><code>text_content</code> Retrieve only text content. Default is <code>False</code>.</li> <li><code>session_id</code> Optional. Provide an existing Session ID.</li> <li><code>proxy</code> Optional. Enable/Disable Proxies.\"</li> </ul>"},{"location":"tools/CSVSearchTool/","title":"CSVSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/CSVSearchTool/#description","title":"Description","text":"<p>This tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file. This feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool, are RAG tools designed for searching different sources of data.</p>"},{"location":"tools/CSVSearchTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/CSVSearchTool/#example","title":"Example","text":"<pre><code>from crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. Agent  will need to provide the CSV path at runtime.\ntool = CSVSearchTool()\n</code></pre>"},{"location":"tools/CSVSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>csv</code> : The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional.</li> </ul>"},{"location":"tools/CSVSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/CodeDocsSearchTool/","title":"CodeDocsSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/CodeDocsSearchTool/#description","title":"Description","text":"<p>The CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation. It enables users to efficiently find specific information or topics within code documentation. By providing a <code>docs_url</code> during initialization, the tool narrows down the search to that particular documentation site. Alternatively, without a specific <code>docs_url</code>, it searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.</p>"},{"location":"tools/CodeDocsSearchTool/#installation","title":"Installation","text":"<p>To start using the CodeDocsSearchTool, first, install the crewai_tools package via pip:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/CodeDocsSearchTool/#example","title":"Example","text":"<p>Utilize the CodeDocsSearchTool as follows to conduct searches within code documentation:</p> <p><pre><code>from crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')\n</code></pre> Note: Substitute 'https://docs.example.com/reference' with your target documentation URL and 'How to use search tool' with the search query relevant to your needs.</p>"},{"location":"tools/CodeDocsSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>docs_url</code>: Optional. Specifies the URL of the code documentation to be searched. Providing this during the tool's initialization focuses the search on the specified documentation content.</li> </ul>"},{"location":"tools/CodeDocsSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/CodeInterpreterTool/","title":"CodeInterpreterTool","text":""},{"location":"tools/CodeInterpreterTool/#description","title":"Description","text":"<p>This tool enables the Agent to execute Python 3 code that it has generated autonomously. The code is run in a secure, isolated environment, ensuring safety regardless of the content. </p> <p>This functionality is particularly valuable as it allows the Agent to create code, execute it within the same ecosystem, obtain the results, and utilize that information to inform subsequent decisions and actions.</p>"},{"location":"tools/CodeInterpreterTool/#requirements","title":"Requirements","text":"<ul> <li>Docker</li> </ul>"},{"location":"tools/CodeInterpreterTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/CodeInterpreterTool/#example","title":"Example","text":"<p>Remember that when using this tool, the code must be generated by the Agent itself. The code must be a Python3 code. And it will take some time for the first time to run because it needs to build the Docker image.</p> <pre><code>from crewai import Agent\nfrom crewai_tools import CodeInterpreterTool\n\nAgent(\n    ...\n    tools=[CodeInterpreterTool()],\n)\n</code></pre> <p>We also provide a simple way to use it directly from the Agent.</p> <pre><code>from crewai import Agent\n\nagent = Agent(\n    ...\n    allow_code_execution=True,\n)\n</code></pre>"},{"location":"tools/ComposioTool/","title":"ComposioTool Documentation","text":""},{"location":"tools/ComposioTool/#description","title":"Description","text":"<p>This tools is a wrapper around the composio set of tools and gives your agent access to a wide variety of tools from the composio SDK.</p>"},{"location":"tools/ComposioTool/#installation","title":"Installation","text":"<p>To incorporate this tool into your project, follow the installation instructions below:</p> <pre><code>pip install composio-core\npip install 'crewai[tools]'\n</code></pre> <p>after the installation is complete, either run <code>composio login</code> or export your composio API key as <code>COMPOSIO_API_KEY</code>.</p>"},{"location":"tools/ComposioTool/#example","title":"Example","text":"<p>The following example demonstrates how to initialize the tool and execute a github action:</p> <ol> <li>Initialize Composio tools</li> </ol> <pre><code>from composio import App\nfrom crewai_tools import ComposioTool\nfrom crewai import Agent, Task\n\n\ntools = [ComposioTool.from_action(action=Action.GITHUB_ACTIVITY_STAR_REPO_FOR_AUTHENTICATED_USER)]\n</code></pre> <p>If you don't know what action you want to use, use <code>from_app</code> and <code>tags</code> filter to get relevant actions</p> <pre><code>tools = ComposioTool.from_app(App.GITHUB, tags=[\"important\"])\n</code></pre> <p>or use <code>use_case</code> to search relevant actions</p> <pre><code>tools = ComposioTool.from_app(App.GITHUB, use_case=\"Star a github repository\")\n</code></pre> <ol> <li>Define agent</li> </ol> <pre><code>crewai_agent = Agent(\n    role=\"Github Agent\",\n    goal=\"You take action on Github using Github APIs\",\n    backstory=(\n        \"You are AI agent that is responsible for taking actions on Github \"\n        \"on users behalf. You need to take action on Github using Github APIs\"\n    ),\n    verbose=True,\n    tools=tools,\n)\n</code></pre> <ol> <li>Execute task</li> </ol> <pre><code>task = Task(\n    description=\"Star a repo ComposioHQ/composio on GitHub\",\n    agent=crewai_agent,\n    expected_output=\"if the star happened\",\n)\n\ntask.execute()\n</code></pre> <ul> <li>More detailed list of tools can be found here</li> </ul>"},{"location":"tools/DALL-ETool/","title":"DALL-E Tool","text":""},{"location":"tools/DALL-ETool/#description","title":"Description","text":"<p>This tool is used to give the Agent the ability to generate images using the DALL-E model. It is a transformer-based model that generates images from textual descriptions. This tool allows the Agent to generate images based on the text input provided by the user.</p>"},{"location":"tools/DALL-ETool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/DALL-ETool/#example","title":"Example","text":"<p>Remember that when using this tool, the text must be generated by the Agent itself. The text must be a description of the image you want to generate.</p> <pre><code>from crewai_tools import DallETool\n\nAgent(\n    ...\n    tools=[DallETool()],\n)\n</code></pre> <p>If needed you can also tweak the parameters of the DALL-E model by passing them as arguments to the <code>DallETool</code> class. For example:</p> <pre><code>from crewai_tools import DallETool\n\ndalle_tool = DallETool(model=\"dall-e-3\",\n                       size=\"1024x1024\",\n                       quality=\"standard\",\n                       n=1)\n\nAgent(\n    ...\n    tools=[dalle_tool]\n)\n</code></pre> <p>The parameters are based on the <code>client.images.generate</code> method from the OpenAI API. For more information on the parameters, please refer to the OpenAI API documentation.</p>"},{"location":"tools/DOCXSearchTool/","title":"DOCXSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/DOCXSearchTool/#description","title":"Description","text":"<p>The DOCXSearchTool is a RAG tool designed for semantic searching within DOCX documents. It enables users to effectively search and extract relevant information from DOCX files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.</p>"},{"location":"tools/DOCXSearchTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package by running the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/DOCXSearchTool/#example","title":"Example","text":"<p>The following example demonstrates initializing the DOCXSearchTool to search within any DOCX file's content or with a specific DOCX file path.</p> <pre><code>from crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')\n</code></pre>"},{"location":"tools/DOCXSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>docx</code>: An optional file path to a specific DOCX document you wish to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching.</li> </ul>"},{"location":"tools/DOCXSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/DirectoryReadTool/","title":"Directory Read","text":"<pre><code># DirectoryReadTool\n\n!!! note \"Experimental\"\n    We are still working on improving tools, so there might be unexpected behavior or changes in the future.\n\n## Description\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents. It can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories. This tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.\n\n## Installation\nTo utilize the DirectoryReadTool in your project, install the `crewai_tools` package. If this package is not yet part of your environment, you can install it using pip with the command below:\n\n```shell\npip install 'crewai[tools]'\n</code></pre> <p>This command installs the latest version of the <code>crewai_tools</code> package, granting access to the DirectoryReadTool among other utilities.</p>"},{"location":"tools/DirectoryReadTool/#example","title":"Example","text":"<p>Employing the DirectoryReadTool is straightforward. The following code snippet demonstrates how to set it up and use the tool to list the contents of a specified directory:</p> <pre><code>from crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')\n</code></pre>"},{"location":"tools/DirectoryReadTool/#arguments","title":"Arguments","text":"<p>The DirectoryReadTool requires minimal configuration for use. The essential argument for this tool is as follows:</p> <ul> <li><code>directory</code>: Optional. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing.</li> </ul>"},{"location":"tools/DirectorySearchTool/","title":"DirectorySearchTool","text":"<p>Experimental</p> <p>The DirectorySearchTool is under continuous development. Features and functionalities might evolve, and unexpected behavior may occur as we refine the tool.</p>"},{"location":"tools/DirectorySearchTool/#description","title":"Description","text":"<p>The DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.</p>"},{"location":"tools/DirectorySearchTool/#installation","title":"Installation","text":"<p>To use the DirectorySearchTool, begin by installing the crewai_tools package. Execute the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/DirectorySearchTool/#initialization-and-usage","title":"Initialization and Usage","text":"<p>Import the DirectorySearchTool from the <code>crewai_tools</code> package to start. You can initialize the tool without specifying a directory, enabling the setting of the search directory at runtime. Alternatively, the tool can be initialized with a predefined directory.</p> <pre><code>from crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')\n</code></pre>"},{"location":"tools/DirectorySearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>directory</code>: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.</li> </ul>"},{"location":"tools/DirectorySearchTool/#custom-model-and-embeddings","title":"Custom Model and Embeddings","text":"<p>The DirectorySearchTool uses OpenAI for embeddings and summarization by default. Customization options for these settings include changing the model provider and configuration, enhancing flexibility for advanced users.</p> <pre><code>tool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/EXASearchTool/","title":"EXASearchTool Documentation","text":""},{"location":"tools/EXASearchTool/#description","title":"Description","text":"<p>The EXASearchTool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the exa.ai API to fetch and display the most relevant search results based on the query provided by the user.</p>"},{"location":"tools/EXASearchTool/#installation","title":"Installation","text":"<p>To incorporate this tool into your project, follow the installation instructions below:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/EXASearchTool/#example","title":"Example","text":"<p>The following example demonstrates how to initialize the tool and execute a search with a given query:</p> <pre><code>from crewai_tools import EXASearchTool\n\n# Initialize the tool for internet searching capabilities\ntool = EXASearchTool()\n</code></pre>"},{"location":"tools/EXASearchTool/#steps-to-get-started","title":"Steps to Get Started","text":"<p>To effectively use the EXASearchTool, follow these steps:</p> <ol> <li>Package Installation: Confirm that the <code>crewai[tools]</code> package is installed in your Python environment.</li> <li>API Key Acquisition: Acquire a exa.ai API key by registering for a free account at exa.ai.</li> <li>Environment Configuration: Store your obtained API key in an environment variable named <code>EXA_API_KEY</code> to facilitate its use by the tool.</li> </ol>"},{"location":"tools/EXASearchTool/#conclusion","title":"Conclusion","text":"<p>By integrating the EXASearchTool into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.</p>"},{"location":"tools/FileReadTool/","title":"FileReadTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/FileReadTool/#description","title":"Description","text":"<p>The FileReadTool conceptually represents a suite of functionalities within the crewai_tools package aimed at facilitating file reading and content retrieval. This suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics. It supports a variety of text-based file formats such as <code>.txt</code>, <code>.csv</code>, <code>.json</code>, and more. Depending on the file type, the suite offers specialized functionality, such as converting JSON content into a Python dictionary for ease of use.</p>"},{"location":"tools/FileReadTool/#installation","title":"Installation","text":"<p>To utilize the functionalities previously attributed to the FileReadTool, install the crewai_tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/FileReadTool/#usage-example","title":"Usage Example","text":"<p>To get started with the FileReadTool:</p> <pre><code>from crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')\n</code></pre>"},{"location":"tools/FileReadTool/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code>: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.</li> </ul>"},{"location":"tools/FileWriteTool/","title":"FileWriterTool Documentation","text":""},{"location":"tools/FileWriteTool/#description","title":"Description","text":"<p>The <code>FileWriterTool</code> is a component of the crewai_tools package, designed to simplify the process of writing content to files. It is particularly useful in scenarios such as generating reports, saving logs, creating configuration files, and more. This tool supports creating new directories if they don't exist, making it easier to organize your output.</p>"},{"location":"tools/FileWriteTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package to use the <code>FileWriterTool</code> in your projects:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/FileWriteTool/#example","title":"Example","text":"<p>To get started with the <code>FileWriterTool</code>:</p> <pre><code>from crewai_tools import FileWriterTool\n\n# Initialize the tool\nfile_writer_tool = FileWriterTool()\n\n# Write content to a file in a specified directory\nresult = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')\nprint(result)\n</code></pre>"},{"location":"tools/FileWriteTool/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>: The name of the file you want to create or overwrite.</li> <li><code>content</code>: The content to write into the file.</li> <li><code>directory</code> (optional): The path to the directory where the file will be created. Defaults to the current directory (<code>.</code>). If the directory does not exist, it will be created.</li> </ul>"},{"location":"tools/FileWriteTool/#conclusion","title":"Conclusion","text":"<p>By integrating the <code>FileWriterTool</code> into your crews, the agents can execute the process of writing content to files and creating directories. This tool is essential for tasks that require saving output data, creating structured file systems, and more. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is straightforward and efficient.</p>"},{"location":"tools/FirecrawlCrawlWebsiteTool/","title":"FirecrawlCrawlWebsiteTool","text":""},{"location":"tools/FirecrawlCrawlWebsiteTool/#description","title":"Description","text":"<p>Firecrawl is a platform for crawling and convert any website into clean markdown or structured data.</p>"},{"location":"tools/FirecrawlCrawlWebsiteTool/#installation","title":"Installation","text":"<ul> <li>Get an API key from firecrawl.dev and set it in environment variables (<code>FIRECRAWL_API_KEY</code>).</li> <li>Install the Firecrawl SDK along with <code>crewai[tools]</code> package:</li> </ul> <pre><code>pip install firecrawl-py 'crewai[tools]'\n</code></pre>"},{"location":"tools/FirecrawlCrawlWebsiteTool/#example","title":"Example","text":"<p>Utilize the FirecrawlScrapeFromWebsiteTool as follows to allow your agent to load websites:</p> <pre><code>from crewai_tools import FirecrawlCrawlWebsiteTool\n\ntool = FirecrawlCrawlWebsiteTool(url='firecrawl.dev')\n</code></pre>"},{"location":"tools/FirecrawlCrawlWebsiteTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code>: Optional. Specifies Firecrawl API key. Defaults is the <code>FIRECRAWL_API_KEY</code> environment variable.</li> <li><code>url</code>: The base URL to start crawling from.</li> <li><code>page_options</code>: Optional. </li> <li><code>onlyMainContent</code>: Optional. Only return the main content of the page excluding headers, navs, footers, etc.</li> <li><code>includeHtml</code>: Optional. Include the raw HTML content of the page. Will output a html key in the response.</li> <li><code>crawler_options</code>: Optional. Options for controlling the crawling behavior.</li> <li><code>includes</code>: Optional. URL patterns to include in the crawl.</li> <li><code>exclude</code>: Optional. URL patterns to exclude from the crawl.</li> <li><code>generateImgAltText</code>: Optional. Generate alt text for images using LLMs (requires a paid plan).</li> <li><code>returnOnlyUrls</code>: Optional. If true, returns only the URLs as a list in the crawl status. Note: the response will be a list of URLs inside the data, not a list of documents.</li> <li><code>maxDepth</code>: Optional. Maximum depth to crawl. Depth 1 is the base URL, depth 2 includes the base URL and its direct children, and so on.</li> <li><code>mode</code>: Optional. The crawling mode to use. Fast mode crawls 4x faster on websites without a sitemap but may not be as accurate and shouldn't be used on heavily JavaScript-rendered websites.</li> <li><code>limit</code>: Optional. Maximum number of pages to crawl.</li> <li><code>timeout</code>: Optional. Timeout in milliseconds for the crawling operation.</li> </ul>"},{"location":"tools/FirecrawlScrapeWebsiteTool/","title":"FirecrawlScrapeWebsiteTool","text":""},{"location":"tools/FirecrawlScrapeWebsiteTool/#description","title":"Description","text":"<p>Firecrawl is a platform for crawling and convert any website into clean markdown or structured data.</p>"},{"location":"tools/FirecrawlScrapeWebsiteTool/#installation","title":"Installation","text":"<ul> <li>Get an API key from firecrawl.dev and set it in environment variables (<code>FIRECRAWL_API_KEY</code>).</li> <li>Install the Firecrawl SDK along with <code>crewai[tools]</code> package:</li> </ul> <pre><code>pip install firecrawl-py 'crewai[tools]'\n</code></pre>"},{"location":"tools/FirecrawlScrapeWebsiteTool/#example","title":"Example","text":"<p>Utilize the FirecrawlScrapeWebsiteTool as follows to allow your agent to load websites:</p> <pre><code>from crewai_tools import FirecrawlScrapeWebsiteTool\n\ntool = FirecrawlScrapeWebsiteTool(url='firecrawl.dev')\n</code></pre>"},{"location":"tools/FirecrawlScrapeWebsiteTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code>: Optional. Specifies Firecrawl API key. Defaults is the <code>FIRECRAWL_API_KEY</code> environment variable.</li> <li><code>url</code>: The URL to scrape.</li> <li><code>page_options</code>: Optional. </li> <li><code>onlyMainContent</code>: Optional. Only return the main content of the page excluding headers, navs, footers, etc.</li> <li><code>includeHtml</code>: Optional. Include the raw HTML content of the page. Will output a html key in the response.</li> <li><code>extractor_options</code>: Optional. Options for LLM-based extraction of structured information from the page content</li> <li><code>mode</code>: The extraction mode to use, currently supports 'llm-extraction'</li> <li><code>extractionPrompt</code>: Optional. A prompt describing what information to extract from the page</li> <li><code>extractionSchema</code>: Optional. The schema for the data to be extracted</li> <li><code>timeout</code>: Optional. Timeout in milliseconds for the request</li> </ul>"},{"location":"tools/FirecrawlSearchTool/","title":"FirecrawlSearchTool","text":""},{"location":"tools/FirecrawlSearchTool/#description","title":"Description","text":"<p>Firecrawl is a platform for crawling and convert any website into clean markdown or structured data.</p>"},{"location":"tools/FirecrawlSearchTool/#installation","title":"Installation","text":"<ul> <li>Get an API key from firecrawl.dev and set it in environment variables (<code>FIRECRAWL_API_KEY</code>).</li> <li>Install the Firecrawl SDK along with <code>crewai[tools]</code> package:</li> </ul> <pre><code>pip install firecrawl-py 'crewai[tools]'\n</code></pre>"},{"location":"tools/FirecrawlSearchTool/#example","title":"Example","text":"<p>Utilize the FirecrawlSearchTool as follows to allow your agent to load websites:</p> <pre><code>from crewai_tools import FirecrawlSearchTool\n\ntool = FirecrawlSearchTool(query='what is firecrawl?')\n</code></pre>"},{"location":"tools/FirecrawlSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code>: Optional. Specifies Firecrawl API key. Defaults is the <code>FIRECRAWL_API_KEY</code> environment variable.</li> <li><code>query</code>: The search query string to be used for searching.</li> <li><code>page_options</code>: Optional. Options for result formatting.</li> <li><code>onlyMainContent</code>: Optional. Only return the main content of the page excluding headers, navs, footers, etc.</li> <li><code>includeHtml</code>: Optional. Include the raw HTML content of the page. Will output a html key in the response.</li> <li><code>fetchPageContent</code>: Optional. Fetch the full content of the page.</li> <li><code>search_options</code>: Optional. Options for controlling the crawling behavior.</li> <li><code>limit</code>: Optional. Maximum number of pages to crawl.</li> </ul>"},{"location":"tools/GitHubSearchTool/","title":"GithubSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/GitHubSearchTool/#description","title":"Description","text":"<p>The GithubSearchTool is a Retrieval-Augmented Generation (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.</p>"},{"location":"tools/GitHubSearchTool/#installation","title":"Installation","text":"<p>To use the GithubSearchTool, first ensure the crewai_tools package is installed in your Python environment:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command installs the necessary package to run the GithubSearchTool along with any other tools included in the crewai_tools package.</p>"},{"location":"tools/GitHubSearchTool/#example","title":"Example","text":"<p>Here\u2019s how you can use the GithubSearchTool to perform semantic searches within a GitHub repository: <pre><code>from crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n    github_repo='https://github.com/example/repo',\n    content_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n    content_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n</code></pre></p>"},{"location":"tools/GitHubSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>github_repo</code> : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search.</li> <li><code>content_types</code> : Specifies the types of content to include in your search. You must provide a list of content types from the following options: <code>code</code> for searching within the code, <code>repo</code> for searching within the repository's general information, <code>pr</code> for searching within pull requests, and <code>issue</code> for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.</li> </ul>"},{"location":"tools/GitHubSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/JSONSearchTool/","title":"JSONSearchTool","text":"<p>Experimental Status</p> <p>The JSONSearchTool is currently in an experimental phase. This means the tool is under active development, and users might encounter unexpected behavior or changes. We highly encourage feedback on any issues or suggestions for improvements.</p>"},{"location":"tools/JSONSearchTool/#description","title":"Description","text":"<p>The JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.</p>"},{"location":"tools/JSONSearchTool/#installation","title":"Installation","text":"<p>To install the JSONSearchTool, use the following pip command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/JSONSearchTool/#usage-examples","title":"Usage Examples","text":"<p>Here are updated examples on how to utilize the JSONSearchTool effectively for searching within JSON files. These examples take into account the current implementation and usage patterns identified in the codebase.</p> <pre><code>from crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')\n</code></pre>"},{"location":"tools/JSONSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>json_path</code> (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.</li> </ul>"},{"location":"tools/JSONSearchTool/#configuration-options","title":"Configuration Options","text":"<p>The JSONSearchTool supports extensive customization through a configuration dictionary. This allows users to select different models for embeddings and summarization based on their requirements.</p> <pre><code>tool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedder\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)\n</code></pre>"},{"location":"tools/MDXSearchTool/","title":"MDXSearchTool","text":"<p>Experimental</p> <p>The MDXSearchTool is in continuous development. Features may be added or removed, and functionality could change unpredictably as we refine the tool.</p>"},{"location":"tools/MDXSearchTool/#description","title":"Description","text":"<p>The MDX Search Tool is a component of the <code>crewai_tools</code> package aimed at facilitating advanced markdown language extraction. It enables users to effectively search and extract relevant information from MD files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.</p>"},{"location":"tools/MDXSearchTool/#installation","title":"Installation","text":"<p>Before using the MDX Search Tool, ensure the <code>crewai_tools</code> package is installed. If it is not, you can install it with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/MDXSearchTool/#usage-example","title":"Usage Example","text":"<p>To use the MDX Search Tool, you must first set up the necessary environment variables. Then, integrate the tool into your crewAI project to begin your market research. Below is a basic example of how to do this:</p> <pre><code>from crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')\n</code></pre>"},{"location":"tools/MDXSearchTool/#parameters","title":"Parameters","text":"<ul> <li>mdx: Optional. Specifies the MDX file path for the search. It can be provided during initialization.</li> </ul>"},{"location":"tools/MDXSearchTool/#customization-of-model-and-embeddings","title":"Customization of Model and Embeddings","text":"<p>The tool defaults to using OpenAI for embeddings and summarization. For customization, utilize a configuration dictionary as shown below:</p> <pre><code>tool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/MySQLTool/","title":"MySQLSearchTool","text":""},{"location":"tools/MySQLTool/#description","title":"Description","text":"<p>This tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology, the MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases. It simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing to perform advanced queries on extensive datasets within a MySQL database.</p>"},{"location":"tools/MySQLTool/#installation","title":"Installation","text":"<p>To install the <code>crewai_tools</code> package and utilize the MySQLSearchTool, execute the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/MySQLTool/#example","title":"Example","text":"<p>Below is an example showcasing how to use the MySQLSearchTool to conduct a semantic search on a table within a MySQL database:</p> <pre><code>from crewai_tools import MySQLSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = MySQLSearchTool(db_uri='mysql://user:password@localhost:3306/mydatabase', table_name='employees')\n</code></pre>"},{"location":"tools/MySQLTool/#arguments","title":"Arguments","text":"<p>The MySQLSearchTool requires the following arguments for its operation:</p> <ul> <li><code>db_uri</code>: A string representing the URI of the MySQL database to be queried. This argument is mandatory and must include the necessary authentication details and the location of the database.</li> <li><code>table_name</code>: A string specifying the name of the table within the database on which the semantic search will be performed. This argument is mandatory.</li> </ul>"},{"location":"tools/MySQLTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = MySQLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\",\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/NL2SQLTool/","title":"NL2SQL Tool","text":""},{"location":"tools/NL2SQLTool/#description","title":"Description","text":"<p>This tool is used to convert natural language to SQL queries. When passsed to the agent it will generate queries and then use them to interact with the database.</p> <p>This enables multiple workflows like having an Agent to access the database fetch information based on the goal and then use the information to generate a response, report or any other output. Along with that proivdes the ability for the Agent to update the database based on its goal.</p> <p>Attention: Make sure that the Agent has access to a Read-Replica or that is okay for the Agent to run insert/update queries on the database.</p>"},{"location":"tools/NL2SQLTool/#requirements","title":"Requirements","text":"<ul> <li>SqlAlchemy</li> <li>Any DB compatible library (e.g. psycopg2, mysql-connector-python)</li> </ul>"},{"location":"tools/NL2SQLTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/NL2SQLTool/#usage","title":"Usage","text":"<p>In order to use the NL2SQLTool, you need to pass the database URI to the tool. The URI should be in the format <code>dialect+driver://username:password@host:port/database</code>.</p> <pre><code>from crewai_tools import NL2SQLTool\n\n# psycopg2 was installed to run this example with PostgreSQL\nnl2sql = NL2SQLTool(db_uri=\"postgresql://example@localhost:5432/test_db\")\n\n@agent\ndef researcher(self) -&gt; Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[nl2sql]\n    )\n</code></pre>"},{"location":"tools/NL2SQLTool/#example","title":"Example","text":"<p>The primary task goal was:</p> <p>\"Retrieve the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of user in each city and sort the results by the average monthly revenue in descending order\"</p> <p>So the Agent tried to get information from the DB, the first one is wrong so the Agent tries again and gets the correct information and passes to the next agent.</p> <p> </p> <p>The second task goal was:</p> <p>\"Review the data and create a detailed report, and then create the table on the database with the fields based on the data provided. Include information on the average, maximum, and minimum monthly revenue for each city, but only include cities that have more than one user. Also, count the number of users in each city and sort the results by the average monthly revenue in descending order.\"</p> <p>Now things start to get interesting, the Agent generates the SQL query to not only create the table but also insert the data into the table. And in the end the Agent still returns the final report which is exactly what was in the database.</p> <p> </p> <p> </p> <p>This is a simple example of how the NL2SQLTool can be used to interact with the database and generate reports based on the data in the database.</p> <p>The Tool provides endless possibilities on the logic of the Agent and how it can interact with the database.</p> <pre><code> DB -&gt; Agent -&gt; ... -&gt; Agent -&gt; DB\n</code></pre>"},{"location":"tools/PDFSearchTool/","title":"PDFSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/PDFSearchTool/#description","title":"Description","text":"<p>The PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently. This capability makes it especially useful for extracting specific information from large PDF files quickly.</p>"},{"location":"tools/PDFSearchTool/#installation","title":"Installation","text":"<p>To get started with the PDFSearchTool, first, ensure the crewai_tools package is installed with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/PDFSearchTool/#example","title":"Example","text":"<p>Here's how to use the PDFSearchTool to search within a PDF document:</p> <pre><code>from crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')\n</code></pre>"},{"location":"tools/PDFSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>pdf</code>: Optional The PDF path for the search. Can be provided at initialization or within the <code>run</code> method's arguments. If provided at initialization, the tool confines its search to the specified document.</li> </ul>"},{"location":"tools/PDFSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/PGSearchTool/","title":"PGSearchTool","text":"<p>Under Development</p> <p>The PGSearchTool is currently under development. This document outlines the intended functionality and interface. As development progresses, please be aware that some features may not be available or could change.</p>"},{"location":"tools/PGSearchTool/#description","title":"Description","text":"<p>The PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology, it aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases. The tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on extensive datasets within a PostgreSQL environment.</p>"},{"location":"tools/PGSearchTool/#installation","title":"Installation","text":"<p>The <code>crewai_tools</code> package, which will include the PGSearchTool upon its release, can be installed using the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>(Note: The PGSearchTool is not yet available in the current version of the <code>crewai_tools</code> package. This installation command will be updated once the tool is released.)</p>"},{"location":"tools/PGSearchTool/#example-usage","title":"Example Usage","text":"<p>Below is a proposed example showcasing how to use the PGSearchTool for conducting a semantic search on a table within a PostgreSQL database:</p> <pre><code>from crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(db_uri='postgresql://user:password@localhost:5432/mydatabase', table_name='employees')\n</code></pre>"},{"location":"tools/PGSearchTool/#arguments","title":"Arguments","text":"<p>The PGSearchTool is designed to require the following arguments for its operation:</p> <ul> <li><code>db_uri</code>: A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database.</li> <li><code>table_name</code>: A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.</li> </ul>"},{"location":"tools/PGSearchTool/#custom-model-and-embeddings","title":"Custom Model and Embeddings","text":"<p>The tool intends to use OpenAI for both embeddings and summarization by default. Users will have the option to customize the model using a config dictionary as follows:</p> <pre><code>tool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/ScrapeWebsiteTool/","title":"ScrapeWebsiteTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/ScrapeWebsiteTool/#description","title":"Description","text":"<p>A tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content. This tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.</p>"},{"location":"tools/ScrapeWebsiteTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/ScrapeWebsiteTool/#example","title":"Example","text":"<pre><code>from crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)\n</code></pre>"},{"location":"tools/ScrapeWebsiteTool/#arguments","title":"Arguments","text":"<ul> <li><code>website_url</code> : Mandatory website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read.</li> </ul>"},{"location":"tools/SeleniumScrapingTool/","title":"SeleniumScrapingTool","text":"<p>Experimental</p> <p>This tool is currently in development. As we refine its capabilities, users may encounter unexpected behavior. Your feedback is invaluable to us for making improvements.</p>"},{"location":"tools/SeleniumScrapingTool/#description","title":"Description","text":"<p>The SeleniumScrapingTool is crafted for high-efficiency web scraping tasks. It allows for precise extraction of content from web pages by using CSS selectors to target specific elements. Its design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.</p>"},{"location":"tools/SeleniumScrapingTool/#installation","title":"Installation","text":"<p>To get started with the SeleniumScrapingTool, install the crewai_tools package using pip:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/SeleniumScrapingTool/#usage-examples","title":"Usage Examples","text":"<p>Below are some scenarios where the SeleniumScrapingTool can be utilized:</p> <pre><code>from crewai_tools import SeleniumScrapingTool\n\n# Example 1: Initialize the tool without any parameters to scrape the current page it navigates to\ntool = SeleniumScrapingTool()\n\n# Example 2: Scrape the entire webpage of a given URL\ntool = SeleniumScrapingTool(website_url='https://example.com')\n\n# Example 3: Target and scrape a specific CSS element from a webpage\ntool = SeleniumScrapingTool(website_url='https://example.com', css_element='.main-content')\n\n# Example 4: Perform scraping with additional parameters for a customized experience\ntool = SeleniumScrapingTool(website_url='https://example.com', css_element='.main-content', cookie={'name': 'user', 'value': 'John Doe'}, wait_time=10)\n</code></pre>"},{"location":"tools/SeleniumScrapingTool/#arguments","title":"Arguments","text":"<p>The following parameters can be used to customize the SeleniumScrapingTool's scraping process:</p> <ul> <li><code>website_url</code>: Mandatory. Specifies the URL of the website from which content is to be scraped.</li> <li><code>css_element</code>: Mandatory. The CSS selector for a specific element to target on the website. This enables focused scraping of a particular part of a webpage.</li> <li><code>cookie</code>: Optional. A dictionary that contains cookie information. Useful for simulating a logged-in session, thereby providing access to content that might be restricted to non-logged-in users.</li> <li><code>wait_time</code>: Optional. Specifies the delay (in seconds) before the content is scraped. This delay allows for the website and any dynamic content to fully load, ensuring a successful scrape.</li> </ul> <p>Attention</p> <p>Since the SeleniumScrapingTool is under active development, the parameters and functionality may evolve over time. Users are encouraged to keep the tool updated and report any issues or suggestions for enhancements.</p>"},{"location":"tools/SerperDevTool/","title":"SerperDevTool Documentation","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/SerperDevTool/#description","title":"Description","text":"<p>This tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the serper.dev API to fetch and display the most relevant search results based on the query provided by the user.</p>"},{"location":"tools/SerperDevTool/#installation","title":"Installation","text":"<p>To incorporate this tool into your project, follow the installation instructions below: <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/SerperDevTool/#example","title":"Example","text":"<p>The following example demonstrates how to initialize the tool and execute a search with a given query:</p> <pre><code>from crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()\n</code></pre>"},{"location":"tools/SerperDevTool/#steps-to-get-started","title":"Steps to Get Started","text":"<p>To effectively use the <code>SerperDevTool</code>, follow these steps:</p> <ol> <li>Package Installation: Confirm that the <code>crewai[tools]</code> package is installed in your Python environment.</li> <li>API Key Acquisition: Acquire a <code>serper.dev</code> API key by registering for a free account at <code>serper.dev</code>.</li> <li>Environment Configuration: Store your obtained API key in an environment variable named <code>SERPER_API_KEY</code> to facilitate its use by the tool.</li> </ol>"},{"location":"tools/SerperDevTool/#parameters","title":"Parameters","text":"<p>The <code>SerperDevTool</code> comes with several parameters that will be passed to the API :</p> <ul> <li> <p>search_url: The URL endpoint for the search API. (Default is <code>https://google.serper.dev/search</code>)</p> </li> <li> <p>country: Optional. Specify the country for the search results.</p> </li> <li>location: Optional. Specify the location for the search results.</li> <li>locale: Optional. Specify the locale for the search results.</li> <li>n_results: Number of search results to return. Default is <code>10</code>.</li> </ul> <p>The values for <code>country</code>, <code>location</code>, <code>locale</code> and <code>search_url</code> can be found on the Serper Playground.</p>"},{"location":"tools/SerperDevTool/#example-with-parameters","title":"Example with Parameters","text":"<p>Here is an example demonstrating how to use the tool with additional parameters:</p> <pre><code>from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    search_url=\"https://google.serper.dev/scholar\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"ChatGPT\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Role of chat gpt in public health\n# Link: https://link.springer.com/article/10.1007/s10439-023-03172-7\n# Snippet: \u2026 ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in\n# ---\n# Title: Potential use of chat gpt in global warming\n# Link: https://link.springer.com/article/10.1007/s10439-023-03171-8\n# Snippet: \u2026 as ChatGPT, have the potential to play a critical role in advancing our understanding of climate\n# ---\n</code></pre> <pre><code>from crewai_tools import SerperDevTool\n\ntool = SerperDevTool(\n    country=\"fr\",\n    locale=\"fr\",\n    location=\"Paris, Paris, Ile-de-France, France\",\n    n_results=2,\n)\n\nprint(tool.run(search_query=\"Jeux Olympiques\"))\n\n# Using Tool: Search the internet\n\n# Search results: Title: Jeux Olympiques de Paris 2024 - Actualit\u00e9s, calendriers, r\u00e9sultats\n# Link: https://olympics.com/fr/paris-2024\n# Snippet: Quels sont les sports pr\u00e9sents aux Jeux Olympiques de Paris 2024 ? \u00b7 Athl\u00e9tisme \u00b7 Aviron \u00b7 Badminton \u00b7 Basketball \u00b7 Basketball 3x3 \u00b7 Boxe \u00b7 Breaking \u00b7 Cano\u00eb ...\n# ---\n# Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques\n# Link: https://tickets.paris2024.org/\n# Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand \u00e9v\u00e9nement sportif au monde.\n# ---\n</code></pre>"},{"location":"tools/SerperDevTool/#conclusion","title":"Conclusion","text":"<p>By integrating the <code>SerperDevTool</code> into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. The updated parameters allow for more customized and localized search results. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.</p>"},{"location":"tools/SpiderTool/","title":"SpiderTool","text":""},{"location":"tools/SpiderTool/#description","title":"Description","text":"<p>Spider is the fastest open source scraper and crawler that returns LLM-ready data. It converts any website into pure HTML, markdown, metadata or text while enabling you to crawl with custom actions using AI.</p>"},{"location":"tools/SpiderTool/#installation","title":"Installation","text":"<p>To use the Spider API you need to download the Spider SDK and the crewai[tools] SDK too:</p> <pre><code>pip install spider-client 'crewai[tools]'\n</code></pre>"},{"location":"tools/SpiderTool/#example","title":"Example","text":"<p>This example shows you how you can use the Spider tool to enable your agent to scrape and crawl websites. The data returned from the Spider API is already LLM-ready, so no need to do any cleaning there.</p> <pre><code>from crewai_tools import SpiderTool\n\ndef main():\n    spider_tool = SpiderTool()\n\n    searcher = Agent(\n        role=\"Web Research Expert\",\n        goal=\"Find related information from specific URL's\",\n        backstory=\"An expert web researcher that uses the web extremely well\",\n        tools=[spider_tool],\n        verbose=True,\n    )\n\n    return_metadata = Task(\n        description=\"Scrape https://spider.cloud with a limit of 1 and enable metadata\",\n        expected_output=\"Metadata and 10 word summary of spider.cloud\",\n        agent=searcher\n    )\n\n    crew = Crew(\n        agents=[searcher],\n        tasks=[\n            return_metadata,\n        ],\n        verbose=2\n    )\n\n    crew.kickoff()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tools/SpiderTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code> (string, optional): Specifies Spider API key. If not specified, it looks for <code>SPIDER_API_KEY</code> in environment variables.</li> <li><code>params</code> (object, optional): Optional parameters for the request. Defaults to <code>{\"return_format\": \"markdown\"}</code> to return the website's content in a format that fits LLMs better.<ul> <li><code>request</code> (string): The request type to perform. Possible values are <code>http</code>, <code>chrome</code>, and <code>smart</code>. Use <code>smart</code> to perform an HTTP request by default until JavaScript rendering is needed for the HTML.</li> <li><code>limit</code> (int): The maximum number of pages allowed to crawl per website. Remove the value or set it to <code>0</code> to crawl all pages.</li> <li><code>depth</code> (int): The crawl limit for maximum depth. If <code>0</code>, no limit will be applied.</li> <li><code>cache</code> (bool): Use HTTP caching for the crawl to speed up repeated runs. Default is <code>true</code>.</li> <li><code>budget</code> (object): Object that has paths with a counter for limiting the amount of pages example <code>{\"*\":1}</code> for only crawling the root page.</li> <li><code>locale</code> (string): The locale to use for request, example <code>en-US</code>.</li> <li><code>cookies</code> (string): Add HTTP cookies to use for request.</li> <li><code>stealth</code> (bool): Use stealth mode for headless chrome request to help prevent being blocked. The default is <code>true</code> on chrome.</li> <li><code>headers</code> (object): Forward HTTP headers to use for all request. The object is expected to be a map of key value pairs.</li> <li><code>metadata</code> (bool): Boolean to store metadata about the pages and content found. This could help improve AI interopt. Defaults to <code>false</code> unless you have the website already stored with the configuration enabled.</li> <li><code>viewport</code> (object): Configure the viewport for chrome. Defaults to <code>800x600</code>.</li> <li><code>encoding</code> (string): The type of encoding to use like <code>UTF-8</code>, <code>SHIFT_JIS</code>, or etc.</li> <li><code>subdomains</code> (bool): Allow subdomains to be included. Default is <code>false</code>.</li> <li><code>user_agent</code> (string): Add a custom HTTP user agent to the request. By default this is set to a random agent.</li> <li><code>store_data</code> (bool): Boolean to determine if storage should be used. If set this takes precedence over <code>storageless</code>. Defaults to <code>false</code>.</li> <li><code>gpt_config</code> (object): Use AI to generate actions to perform during the crawl. You can pass an array for the <code>\"prompt\"</code> to chain steps.</li> <li><code>fingerprint</code> (bool): Use advanced fingerprint for chrome.</li> <li><code>storageless</code> (bool): Boolean to prevent storing any type of data for the request including storage and AI vectors embedding. Defaults to <code>false</code> unless you have the website already stored.</li> <li><code>readability</code> (bool): Use readability to pre-process the content for reading. This may drastically improve the content for LLM usage. <code>return_format</code> (string): The format to return the data in. Possible values are <code>markdown</code>, <code>raw</code>, <code>text</code>, and <code>html2text</code>. Use <code>raw</code> to return the default format of the page like HTML etc.</li> <li><code>proxy_enabled</code> (bool): Enable high performance premium proxies for the request to prevent being blocked at the network level.</li> <li><code>query_selector</code> (string): The CSS query selector to use when extracting content from the markup.</li> <li><code>full_resources</code> (bool): Crawl and download all the resources for a website.</li> <li><code>request_timeout</code> (int): The timeout to use for request. Timeouts can be from <code>5-60</code>. The default is <code>30</code> seconds.</li> <li><code>run_in_background</code> (bool): Run the request in the background. Useful if storing data and wanting to trigger crawls to the dashboard. This has no effect if storageless is set.</li> </ul> </li> </ul>"},{"location":"tools/TXTSearchTool/","title":"TXTSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/TXTSearchTool/#description","title":"Description","text":"<p>This tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file. It allows for semantic searching of a query within a specified text file's content, making it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.</p>"},{"location":"tools/TXTSearchTool/#installation","title":"Installation","text":"<p>To use the TXTSearchTool, you first need to install the crewai_tools package. This can be done using pip, a package manager for Python. Open your terminal or command prompt and enter the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command will download and install the TXTSearchTool along with any necessary dependencies.</p>"},{"location":"tools/TXTSearchTool/#example","title":"Example","text":"<p>The following example demonstrates how to use the TXTSearchTool to search within a text file. This example shows both the initialization of the tool with a specific text file and the subsequent search within that file's content.</p> <pre><code>from crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')\n</code></pre>"},{"location":"tools/TXTSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>txt</code> (str): Optional. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file.</li> </ul>"},{"location":"tools/TXTSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/VisionTool/","title":"Vision Tool","text":""},{"location":"tools/VisionTool/#description","title":"Description","text":"<p>This tool is used to extract text from images. When passed to the agent it will extract the text from the image and then use it to generate a response, report or any other output. The URL or the PATH of the image should be passed to the Agent.</p>"},{"location":"tools/VisionTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/VisionTool/#usage","title":"Usage","text":"<p>In order to use the VisionTool, the OpenAI API key should be set in the environment variable <code>OPENAI_API_KEY</code>.</p> <pre><code>from crewai_tools import VisionTool\n\nvision_tool = VisionTool()\n\n@agent\ndef researcher(self) -&gt; Agent:\n    return Agent(\n        config=self.agents_config[\"researcher\"],\n        allow_delegation=False,\n        tools=[vision_tool]\n    )\n</code></pre>"},{"location":"tools/WebsiteSearchTool/","title":"WebsiteSearchTool","text":"<p>Experimental Status</p> <p>The WebsiteSearchTool is currently in an experimental phase. We are actively working on incorporating this tool into our suite of offerings and will update the documentation accordingly.</p>"},{"location":"tools/WebsiteSearchTool/#description","title":"Description","text":"<p>The WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites. It aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently. This tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest. Please note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.</p>"},{"location":"tools/WebsiteSearchTool/#installation","title":"Installation","text":"<p>To prepare your environment for when the WebsiteSearchTool becomes available, you can install the foundational package with:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command installs the necessary dependencies to ensure that once the tool is fully integrated, users can start using it immediately.</p>"},{"location":"tools/WebsiteSearchTool/#example-usage","title":"Example Usage","text":"<p>Below are examples of how the WebsiteSearchTool could be utilized in different scenarios. Please note, these examples are illustrative and represent planned functionality:</p> <pre><code>from crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')\n</code></pre>"},{"location":"tools/WebsiteSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>website</code>: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.</li> </ul>"},{"location":"tools/WebsiteSearchTool/#customization-options","title":"Customization Options","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/XMLSearchTool/","title":"XMLSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/XMLSearchTool/#description","title":"Description","text":"<p>The XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files. Ideal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path. By specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.</p>"},{"location":"tools/XMLSearchTool/#installation","title":"Installation","text":"<p>To start using the XMLSearchTool, you must first install the crewai_tools package. This can be easily done with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/XMLSearchTool/#example","title":"Example","text":"<p>Here are two examples demonstrating how to use the XMLSearchTool. The first example shows searching within a specific XML file, while the second example illustrates initiating a search without predefining an XML path, providing flexibility in search scope.</p> <pre><code>from crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')\n</code></pre>"},{"location":"tools/XMLSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>xml</code>: This is the path to the XML file you wish to search. It is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the <code>run</code> method's arguments to execute a search.</li> </ul>"},{"location":"tools/XMLSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/","title":"YoutubeChannelSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/YoutubeChannelSearchTool/#description","title":"Description","text":"<p>This tool is designed to perform semantic searches within a specific Youtube channel's content. Leveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results, making it invaluable for extracting information or finding specific content without the need to manually sift through videos. It streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.</p>"},{"location":"tools/YoutubeChannelSearchTool/#installation","title":"Installation","text":"<p>To utilize the YoutubeChannelSearchTool, the <code>crewai_tools</code> package must be installed. Execute the following command in your shell to install:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/#example","title":"Example","text":"<p>To begin using the YoutubeChannelSearchTool, follow the example below. This demonstrates initializing the tool with a specific Youtube channel handle and conducting a search within that channel's content.</p> <pre><code>from crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool to search within any Youtube channel's content the agent learns about during its execution\ntool = YoutubeChannelSearchTool()\n\n# OR\n\n# Initialize the tool with a specific Youtube channel handle to target your search\ntool = YoutubeChannelSearchTool(youtube_channel_handle='@exampleChannel')\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>youtube_channel_handle</code> : A mandatory string representing the Youtube channel handle. This parameter is crucial for initializing the tool to specify the channel you want to search within. The tool is designed to only search within the content of the provided channel handle.</li> </ul>"},{"location":"tools/YoutubeChannelSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/","title":"YoutubeVideoSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/YoutubeVideoSearchTool/#description","title":"Description","text":"<p>This tool is part of the <code>crewai_tools</code> package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques. It is one of several \"Search\" tools in the package that leverage RAG for different sources. The YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL, or they can target their search to a specific Youtube video by providing its URL.</p>"},{"location":"tools/YoutubeVideoSearchTool/#installation","title":"Installation","text":"<p>To utilize the YoutubeVideoSearchTool, you must first install the <code>crewai_tools</code> package. This package contains the YoutubeVideoSearchTool among other utilities designed to enhance your data analysis and processing tasks. Install the package by executing the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/#example","title":"Example","text":"<p>To integrate the YoutubeVideoSearchTool into your Python projects, follow the example below. This demonstrates how to use the tool both for general Youtube content searches and for targeted searches within a specific video's content.</p> <pre><code>from crewai_tools import YoutubeVideoSearchTool\n\n# General search across Youtube content without specifying a video URL, so the agent can search within any Youtube video content it learns about irs url during its operation\ntool = YoutubeVideoSearchTool()\n\n# Targeted search within a specific Youtube video's content\ntool = YoutubeVideoSearchTool(youtube_video_url='https://youtube.com/watch?v=example')\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/#arguments","title":"Arguments","text":"<p>The YoutubeVideoSearchTool accepts the following initialization arguments:</p> <ul> <li><code>youtube_video_url</code>: An optional argument at initialization but required if targeting a specific Youtube video. It specifies the Youtube video URL path you want to search within.</li> </ul>"},{"location":"tools/YoutubeVideoSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"}]}